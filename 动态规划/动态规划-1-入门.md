# 动态规划-1 入门篇

[toc]

动态规划一般是求解问题的最优解, 往往需要求"**最值**".

求解动态规划问题:

1. 判断是否有 `最优子结构`, 也就是问题可以被分解为多个子问题, 而且子问题之间必须相互`独立`, 如果不满足, 则不是动态规划问题.

2. 尝试写 `状态转移方程`, 步骤如下:

   1. 先确定何为 `状态`: 状态就是原问题和子问题中**变化的量**.

   2. 再明确何为 `选择`: 选择就是导致`状态` 变化的行为.

   3. 确定思路:

      + `自顶向下` —> `递归函数`: 此时需要明确**递归函数**的定义:

        + 函数的输入值一般为 `状态`;
        + 函数的返回值一般为原问题和子问题的求解量;

        此外, 递归还要确定递归树的展开方式和子递归返回值的使用方式.

        在写出递归函数之后, 再画出递归树, 判断是否存在 `重叠子问题`,

        如果存在`重叠子问题`, 则可加入 `备忘录`, 消除重叠子问题, 优化时间复杂度.

        另外对于`备忘录`, 还可以进一步精简空间占用, 优化空间复杂度.

      + `自底向上` —> `迭代`: 此时需要明确**dp数组**的定义. [**推荐**]

        1. `索引`是: `状态`, 即变化量

        2. `数值`是: 计算量, 即问题待求解值

        3. 其他要点:

           + 确定数组长度

           + 如何对数组做**初始化**
           + 如何自底向上第更新数组的值.

   4. 明确 base case, 也就是基础情况下的结果

3. 综合上述, 得到完整的解法.

### 例子: 322. 零钱兑换

> <https://leetcode.cn/problems/coin-change/>

> 给定不同面额的硬币 `coins` 和一个总金额 `amount`。编写一个函数来计算**可以凑成总金额所需的最少的硬币个数**。如果没有任何一种硬币组合能组成总金额，返回 -1。
>
> 你可以认为**每种硬币的数量是无限的**。
>
> **示例 1：**
>
> ```
> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1
> ```

求解过程:

1. 判断是否存在 `最优子结构`: **凑零钱问题的子问题之间是相互独立的**, 例如, 凑出总数为`amount-x`元的方案和凑出总数为`amount`元的方案之间没有约束关系. 而且, 一旦知道了凑出总数为 `amount-x`元的最优方案, 则`amount`元的方案就是在此基础上加一即可(假设有面值为`x`的硬币). 如果存在多个可能的`x`,在则取方案总数的最小值即可, 即:
   $$
   凑出amount的最小硬币数 = \min{\{凑出amount-x的硬币数+1|x\in{coins}\}}
   $$
   因此存在最优子结构, 是一个动态规划问题.

2. 明确`状态`: 这里原问题(例如 11 元)和子问题(例如 10 元)中变量的量是金额,即`amount`, 所以状态就是 `amount`.

3. 明确`选择`: 导致状态变化的动作就是**每步选择的硬币**, 如果当前金额为`amount`, 当前硬币面值为`coin`, 则选择为`amount-coin`.

4. 明确 `基础情况`, 基础情况就是:

   + 如果`amount`为 0, 则返回 0;

   + 如果`amount`为 负数, 则返回 -1;

     > 在做选择的时候, 我们先不判断选择的硬盘面额和现有金额的大小关系, 而是先得到 $amount-coin$, 然后判断这个值是否是负数, 如果是负数说明这个选择不可能, 此时返回 -1

在明确了上述情况之后, 我们需要进一步确定是`自顶向下`解决还是`自底向上`解决.

#### 自顶向下的递归解法

首先看`自顶向下`方案:

自顶向下就是**递归**方法, **所谓自顶向下, 就是大金额开始**. 那么此时我们需要**明确递归函数的输入输出**, 也就是递归函数的签名.

一般来说, 递归函数的**输入值**是`状态`, 本例即 `amount`; **返回值**是问题的求解量, 本例即最小的硬币数量, 即:

```python
def dp(amount_step: int ) -> int:
    """
   参数: 每一次递归的目标金额
   返回值: 目标金额的最小硬币数量
    """
    ...
```

在递归问题中还有一个关键问题, 就是**如何展开递归**, 即**递归树的节点怎么展开**的问题.

在经典的二叉树问题中, 递归往往是在左右子节点上展开, 而在其他问题上, 就需要具体问题具体分析. 一般来说, 这需要看每一步的**选择的可能性**, **有多少可能性, 递归树就有多少种可能的分支**.

在本例中, 如果**存在 n 种不同的硬币, 则每一次选择硬币时, 可能的选择也有 n 种, 因此递归要在 n 种硬币上展开**. 即:

```python
for coin in coins:
  # 在 n 种 可能的选择上展开:
  ... = dp(..)
```

 在确定递归的签名和展开方式之后, 还要一个问题就是**如何使用各个子递归的返回值**. 由于这是一个**最值问题**(求硬币数量的最小值), 因此子递归的返回值也要**基于最小值优先的原则筛选**. 即:
$$
\text{最少硬币数量} = min(\text{当前最少硬币数量},\text{递归函数返回值+1})
$$

此外, 使用子递归的返回值的时候, **也要判断子递归的返回值的合法性**, 比如在本例中, 如果子递归的返回值为 -1 , 则表示当前的选择不可能, 此时应该忽略这个子递归的返回值.

> 递归函数返回值表示减去当前这个硬币面额的金额的所需最少硬币数量.

综上, 状态转移方程应为: (两个基础情况, 一个转移)
$$
dp(n)=
\begin{cases}
0,& \quad n=0 \\
-1,& \quad n<0 \\
min\{dp(n-coin)+1|coin \in coins\},& \quad n>0
\end{cases}
$$

> 由于要考虑基础情况, 因此形式化的状态转移方程一般都是**分段函数**的形式.

从状态转移方程可以看出这是一个 **自顶向下** 的解决方案.

据此, 我们可以写出计算过程的代码实现:

```python
from typing import *
class Solution(object):
    def coinChange(self, coins: List[int], amount: int):
        def dp(amount_dp: int) -> int:
            """ 子递归寻找指定金额的最小硬币数
            
            Args:
                amount_dp: 当前的金额总数

            Returns:
                当前金额所需的最小硬币数, 
                如果找不到合理的方案, 则返回 -1
            """
            # 先写基础情况:
            if amount_dp == 0:
                return 0
            if amount_dp < 0:
                return -1
            # 基于最小值优先的方式筛选递归返回值,
            # 先初始化一个极大值
            min_coin_num = float("inf")
            # 再在各个硬币上展开递归:
            for coin in coins:
                # 如果选择使用当前的 coin, 则剩下的最小硬币数量:
                # amount-coin 代表使用这个硬币(即 "选择" ).
                dp_result = dp(amount_dp - coin)
                # 最小值筛选:
                # 先处理特殊情况: -1
                # 自递归返回 -1 说明这个选择走不通了, 可以忽略
                if dp_result == -1:
                    continue
                # 最值问题, 按照最值原则使用自递归返回值:
                # 这里的意思, 如果使用当前的硬币后的数量少于当前的最小硬币数, 则使用此种选择
                # 这里+1 是为了补上 amount-coin 时用的那一个硬币
                min_coin_num = min(min_coin_num, dp_result + 1)
            # 没找到方案, 返回 -1
            # 判断一下是否找到了方案:
            if min_coin_num == float("inf"):
                return -1
            else:
                return min_coin_num

        return dp(amount)

```

下面以硬币 [1, 2, 3], 金额为 5 为例, 画出**递归树**如下:

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210308145522.png" alt="image-20210308145522914" style="zoom:60%;" />

可以看到这里存在大量重复计算的节点, 即`重叠子问题`, 因此时间效率不高. 下面先对时间复杂度做分析.

> 直接写 自顶而下的递归解法可能存在 `重叠子问题`, 需要进一步优化.

在递归算法中,
$$
\text{总的时间复杂度} = \text{子问题的总数} \times \text{每个子问题的时间复杂度}
$$

从递归树可以直观看出, 假设硬币数量为 $k$ , 金额为 $n$ , 子问题的总数就是递归树的节点数为 $\frac{k^{n}-1}{k-1}$ 个, 即$O(k^{n})$ 数量级.

> **补充**: 怎样估算树的节点数量?
>
> <todo>

而每个子递归中都包含一个循环, 因此子问题的时间复杂度为 $O(k)$.

因此, 总的时间复杂度为 $O(k \times k^{n})$, 为**指数级别**.

##### 引入备忘录消除重叠子问题(记忆化搜索)

要消除递归中的重叠子问题, 可引入`备忘录`, 所谓"备忘录"可以是一个数组或者字典等结构, 本例子中由于金额的数字不连续, 因此使用字典较为方便.

`备忘录`放在自递归的外面, 在自递归内部读写. 为了避免`重复子问题`, **自递归的入口处要先判断备忘录中是否已经存在对应的记录, 如果存在, 就直接返回.**

下面是引入备忘录后的递归解法:

```python
class Solution(object):
    def coinChange(self, coins, amount):
        # ※ 初始化备忘录(字典):
        memo = {}
        def dp(amount_dp):
            # ※ 每次在计算前先检查备忘录, 如果备忘录中存在,则直接返回:
            if amount_dp in memo:
                return memo[amount_dp]
            
            # 先写基础情况:
            if amount_dp == 0:
                return 0
            if amount_dp < 0:
                return -1
            # 基于最小值优先的方式筛选递归返回值,
            # 先初始化一个极大值
            min_coin_num = float("inf")
            # 再在各个硬币上展开递归:
            for coin in coins:
                # 如果选择使用当前的 coin, 则剩下的最小硬币数量:
                # amount-coin 代表使用这个硬币(即 "选择" ).
                dp_result = dp(amount_dp - coin)
                # 最小值筛选:
                # 先处理特殊情况: -1
                if dp_result == -1:
                    continue
                # 这里的意思, 如果使用当前的硬币后的数量少于当前的最小硬币数, 则使用此种选择
                # 这里+1 是为了补上 amount-coin 时用的那一个硬币
                min_coin_num = min(min_coin_num, dp_result + 1)
            
            # ※ 每次在返回前先更新到备忘录:
            # 判断一下是否找到了方案:
            if min_coin_num == float("inf"):
                memo[amount_dp] = -1
            else:
                memo[amount_dp] = min_coin_num
            # 然后再返回:
            return memo[amount_dp]

        return dp(amount)
```

此时递归树实际上被`剪枝`, 从一个树形结构"退化"为了一个一维连续展开, 如下图:

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210308152614.png" alt="image-20210308152614820" style="zoom:60%;" />

此时子问题数量从 $O(k^{n})$ 减少到了 $O(n)$ , 直接下降了一个数量级.

则此时总的时间复杂度为 $O(k \times n)$ .

注意此时`备忘录` memo 中保存了所有展开节点的值, 因此空间复杂度为 $O(n)$ .

这里的空间复杂度实际上还可以进一步优化为 $O(1)$, 此优化过程称为 `状态压缩`.

> <todo> 补充 **状态压缩**

#### 自底向上的迭代解法[**推荐**]

上面的 自顶向下的迭代解法 存在一定的函数调用开销, 而且容易存在 `重复子问题`, 因此, 后面我们尽可能使用 **自底向上的迭代解法**.

在上述加入`备忘录`的递归解法中, 我们可以看到子递归的主要工作是更新备忘录中的值, 那自然可以想到能否**脱离递归, 直接使用迭代的方式修改备忘录的值**. 此时`递归函数dp` 变为了 `dp 数组/字典`, 直接充当备忘录的功能.

> 迭代解法不存在 `重复子问题`

此时, 关键是

1. 明确 `dp 数组`中**数值(或者 value)的意义和索引(或者key)的定义方式**, 以及**如何初始化**
2. 确定**递推公式**
3. 明确所有可能的**边界条件**

这里 `基础条件`, `状态` 和 `选择` 与上述自顶向下的方法没有区别.

而 `dp 数组` 定义为: **当目标金额为 `n` 时, 最少需要 `dp[n]` 个硬币**

> 总结 `dp` 函数与 `dp` 数组/字典 如下:
>
> + **递归 `dp` 函数**:
>    1. `输入参数`是: 状态, 即目标金额
>     2. `返回值`是: 计算量, 即最少的硬币数量
>      3. 其他要点:
>         + 使用备忘录消除`重复子问题`;
>         + 如何使用自递归返回值
> + **迭代 `dp` 数组/字典**:
>
>  1. `索引`是: 状态, 即目标金额
>
>  2. `数值`是: 计算量, 即最少的硬币数量
>
>  3. 其他要点:
>
>     + 确定数组长度
>
>     + 如何对数组做**初始化**
>      + 如何自底向上第更新数组的值.

注意这里的`dp 数组` 实际和上面的`备忘录 memo`是一样的. 因此其长度也需要能够完整记录下每个可能的取值,

如果金额为`n`, 则至少需要 `n+1`个位置. 例如, 金额为 $5$, 则至少需要 $5,4,3,2,1,0$ 的保存位置( $-1$ 可以直接返回 $-1$ , 而 $0$ 因为需要参与迭代, 因此需要保存). 这里也可以从数组下标中理解为什么是 n+1, 这是**因为数组下标从 0 开始, 所以需要 n+1**.

再看迭代的层数, 本例外层是一个迭代, 其用来填充 `dp 数组`. 内层就是每个子问题的计算过程, 本例子中**子问题的计算也需要一个迭代**(即存在 `k`个选择的可能性), 因此这里是一个**两层迭代**.

因此时间复杂度也是 $O(n \times k)$ .

此时的状态转移方程和上面一样:
$$
dp[n]=
\begin{cases}
-1,& \quad \text{n<0 数组越界} \\
0,& \quad \text{n=0} \\
min\{dp[n-coin]+1|coin \in coins\},& \quad \text{n>0}
\end{cases}
$$

> **注意**:
>
> 可以看出, 递归和迭代的 状态转移方程 一样, 不过在实现时, *递归是从 n 开始递归, 所以是 自顶而下; 而迭代是从 0 下标开始, 所以是自底而上.*

写出代码实现:

```python
class Solution(object):
    def coinChange(self, coins, amount):
        # 初始化 dp 数组, 设置初始值为极大值
        # 注意这里不能使用 0 作为初始化值
        dp = [float("inf") for _ in range(amount + 1)]
        # 设置基础情况
        dp[0] = 0
        # 迭代开始:
        # 注意, 由于 Python range 的特点, 从 0 迭代到 amount 要写作 range(amount+1)
        for i in range(amount + 1):
            for coin in coins:
                # i-coin 代表选择
                # 判断边界情况:
                if i - coin < 0:
                    continue
                # 状态转移过程:
                dp[i] = min(dp[i], 1 + dp[i - coin])
        # 判断是否找到了方案:
        # 上述遍历的要求是目标金额(i-coin)不能为负数, 因此不是所有的金额都有解(例如硬币为[3,4,5], 目标金额为2), 
        # 所以这里要判断是否为 -1
        if dp[amount] == float("inf"):
            return -1
        else:
            return dp[amount]
```

注意:

+ 这里的迭代是从 0 开始, 逐渐增大到 amount 的, 因此是自底向上.

+ 而递归中, 是从 amount 开始, 主键减小到 0 的, 因此是自顶向下.

特别注意这里的**初始化**细节: 除了`dp[0]`初始化为`0`之外, 其他的元素都应该初始化为极大值`float(inf)`, 这是因为当`n=0`时, 有特殊含义, 当其他的元素对应的值还没计算出来, 由于我们是求最小值, 因此未计算值初始化为极大值.

另外要特别注意这里`选择`的体现:`amount-coin`, 以及选择的影响: `1+dp[i-coin]` 和最小值的选择过程: `min(dp[i],...)`

上述的两个循环也可以替换顺序, 从而避免`i-coin < 0`的判断, 代码如下:

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount + 1)
        dp[0] = 0
        
        for coin in coins:
            for x in range(coin, amount + 1):
                dp[x] = min(dp[x], dp[x - coin] + 1)
        return dp[amount] if dp[amount] != float('inf') else -1 
```

> 本题也可以视为是一个 `完全背包问题`, 其对应解法见  [动态规划3-背包问题.md](动态规划3-背包问题.md)

### 典型题目
