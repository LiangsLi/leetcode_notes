# 动态规划之序列问题

<!--ts-->
* [动态规划之序列问题](动态规划-2-序列问题.md#动态规划之序列问题)
         * [题型分析](动态规划-2-序列问题.md#题型分析)
   * [单个序列问题](动态规划-2-序列问题.md#单个序列问题)
         * [<a href="https://leetcode.cn/problems/maximum-subarray/" rel="nofollow">53. 最大子数组和</a>](动态规划-2-序列问题.md#53-最大子数组和)
            * [分析(动态规划)](动态规划-2-序列问题.md#分析动态规划)
            * [分析(分治法)](动态规划-2-序列问题.md#分析分治法)
         * [<a href="https://leetcode.cn/problems/maximum-product-subarray/" rel="nofollow">152. 乘积最大子数组</a>](动态规划-2-序列问题.md#152-乘积最大子数组)
            * [分析](动态规划-2-序列问题.md#分析)
         * [<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" rel="nofollow">300. 最长递增子序列</a>](动态规划-2-序列问题.md#300-最长递增子序列)
            * [分析(动态规划)](动态规划-2-序列问题.md#分析动态规划-1)
            * [分析(<strong>二分查找</strong>解法)](动态规划-2-序列问题.md#分析二分查找解法)
         * [<a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/" rel="nofollow">673. 最长递增子序列的个数</a>](动态规划-2-序列问题.md#673-最长递增子序列的个数)
            * [分析(动态规划)](动态规划-2-序列问题.md#分析动态规划-2)
            * [分析(<strong>二分查找</strong>解法)](动态规划-2-序列问题.md#分析二分查找解法-1)
         * [<a href="https://leetcode.cn/problems/longest-continuous-increasing-subsequence/" rel="nofollow">674. 最长连续递增序列</a>](动态规划-2-序列问题.md#674-最长连续递增序列)
            * [分析(动态规划解法)](动态规划-2-序列问题.md#分析动态规划解法)
            * [分析(<strong>贪心</strong>解法)](动态规划-2-序列问题.md#分析贪心解法)
         * [<a href="https://leetcode-cn.com/problems/russian-doll-envelopes/" rel="nofollow">354. 俄罗斯套娃信封问题</a>](动态规划-2-序列问题.md#354-俄罗斯套娃信封问题)
            * [分析](动态规划-2-序列问题.md#分析-1)
         * [<a href="https://leetcode.cn/problems/house-robber/" rel="nofollow">198. 打家劫舍</a>](动态规划-2-序列问题.md#198-打家劫舍)
            * [分析](动态规划-2-序列问题.md#分析-2)
         * [<a href="https://leetcode.cn/problems/house-robber-ii/" rel="nofollow">213. 打家劫舍 II</a>](动态规划-2-序列问题.md#213-打家劫舍-ii)
            * [分析](动态规划-2-序列问题.md#分析-3)
   * [两个序列问题](动态规划-2-序列问题.md#两个序列问题)
         * [<a href="https://leetcode.cn/problems/maximum-length-of-repeated-subarray/" rel="nofollow">718. 最长重复子数组</a>](动态规划-2-序列问题.md#718-最长重复子数组)
            * [分析](动态规划-2-序列问题.md#分析-4)
         * [<a href="https://leetcode-cn.com/problems/longest-common-subsequence/" rel="nofollow">1143. 最长公共子序列</a>](动态规划-2-序列问题.md#1143-最长公共子序列)
            * [分析](动态规划-2-序列问题.md#分析-5)
         * [583. <a href="https://leetcode-cn.com/problems/delete-operation-for-two-strings" rel="nofollow">两个字符串的删除操作</a>](动态规划-2-序列问题.md#583-两个字符串的删除操作)
            * [分析](动态规划-2-序列问题.md#分析-6)
         * [712. <a href="https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/" rel="nofollow">两个字符串的最小ASCII删除和</a>](动态规划-2-序列问题.md#712-两个字符串的最小ascii删除和)
            * [分析](动态规划-2-序列问题.md#分析-7)
         * [<a href="https://leetcode.cn/problems/uncrossed-lines/" rel="nofollow">1035. 不相交的线</a>](动态规划-2-序列问题.md#1035-不相交的线)
            * [分析](动态规划-2-序列问题.md#分析-8)
         * [72. <a href="https://leetcode-cn.com/problems/edit-distance/" rel="nofollow">编辑距离</a>](动态规划-2-序列问题.md#72-编辑距离)
            * [分析](动态规划-2-序列问题.md#分析-9)
            * [分析](动态规划-2-序列问题.md#分析-10)
         * [<a href="https://leetcode.cn/problems/is-subsequence/" rel="nofollow">392. 判断子序列</a>](动态规划-2-序列问题.md#392-判断子序列)
            * [分析(双指针-贪心解法)](动态规划-2-序列问题.md#分析双指针-贪心解法)
   * [单序列双指针](动态规划-2-序列问题.md#单序列双指针)
         * [<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" rel="nofollow">516. 最长回文子序列</a>](动态规划-2-序列问题.md#516-最长回文子序列)
            * [分析](动态规划-2-序列问题.md#分析-11)
         * [<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" rel="nofollow">5. 最长回文子串</a>](动态规划-2-序列问题.md#5-最长回文子串)
            * [分析](动态规划-2-序列问题.md#分析-12)
         * [<a href="https://leetcode.cn/problems/palindromic-substrings/" rel="nofollow">647. 回文子串</a>](动态规划-2-序列问题.md#647-回文子串)
            * [分析](动态规划-2-序列问题.md#分析-13)

<!-- Created by https://github.com/ekalinin/github-markdown-toc -->
<!-- Added by: huayongli, at: Mon Jan 15 20:06:24 CST 2024 -->

<!--te-->

> **特别约定:**
>
> + `s[i,j]` 表示 `s[i]`开始, `s[j]`结尾的子串, 注意包括字符 `s[j]` ;
> + `s[i,j)`以及 `s[i:j]` 表示 `s[i]`开始, `s[j-1]`结尾的子串, 不包括字符 `s[j]` ;

一旦涉及到**子序列和最值**，那几乎可以肯定，**考察的是动态规划技巧，时间复杂度一般都是 O(n^2)**。

> $O(n^2)$ 可能不是这类题目的最佳解法, 有的题目使用**二分查找法**等方法可以取得更好的时间性能.

动态规划解决序列问题的套路:

+ 在**一个序列**找到一个满足最值条件的**子序列**(可以是*连续*的,也可以是*不连续*的):

  > 1. **单指针**情况:
  >+ `dp` 数组`dp[i]` 的定义一般为 `以 seq[i]结尾的最xx的序列的xx`;
  >
  > + 数组长度一般为 $n$
  >
  > + 一般 0 是边界情况, 指针从 1 开始迭代;
  >
  > + 例子: **#53.最大子序和**
  >
  >
  >2. **双指针**情况:
  > + `dp`数组 `dp[i][j]` 的定义一般为 `seq[i,j]的最xx的子序列的xx`
  >
  > + 单序列的双指针, 先确定递推关系, 然后画出`dp`数组,确定初始化, 根据要计算的空格确定迭代方式
  >
  > + 例子: [#516](##516) 最长回文子序列
  >
  >
  >
  
+ 在**两个序列**找到一个满足最值条件的**子序列**(可以是*连续*的,也可以是*不连续*的)

  > 两个序列的情况一般都是**双指针**:
  >
  > + `dp` 数组定义为 `dp[i][j]为s1[0,i)和s2[0,j)的最XX的子序列的xx`; (注意不包含 `s1[i]` 和 `s2[j]`).
  > + 数组长度一般为 $(n+1) \times (m+1)$
  > + 一般 0 是边界情况, 两个指针都从 1 开始迭代
  > + 例子: **#1143** 最长公共子序列 , **#72** 编辑距离
  >
  >

#### 题型分析

有的题目确定了`dp`数组的定义就很容易写出 状态转移过程 了(例如**#53.最大子序和**); 但有的题目需要进一步分析才能写出 状态转移过程 (例如 **#1143.最长公共子序列** 和 **#72.编辑距离**); 还有的题目的转移需要进一步的迭代才能确定(例如**#300.最长递增子序列**). 此外, 还有一部分题目, 求解的量需要转换一下之后才是一个动态规划子序列问题, 这类题目需要仔细分析(例如**#583.两个字符串的删除操作** 和 **#712.两个字符串的最小ASCII删除和**)

确定了`dp`数组的定义不能完全解决问题, 还需要确定 **数组长度, 初始化方式, 状态转移, 边界情况, 迭代开始, 终止索引**等

## 单个序列问题

**单序列单指针**情况:

+ `dp` 数组`dp[i]` 的定义一般为 `以 seq[i]结尾的最xx的序列的xx`;

+ 数组长度一般为 $n$

+ 一般 0 是边界情况, 指针从 1 开始迭代;

+ 例子: **#53.最大子序和**

#### [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

> 难度中等6025
>
> 给定一个整数数组 `nums` ，找到一个具有**最大和**的**连续子数组**（子数组最少包含一个元素），返回其最大和。
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```

##### 分析(动态规划)

定义 **`dp[i]`为以 `num[i]`为结尾的 拥有最大和的 连续子数组的 和**.

> 注意这里不能定义 `dp[i]` 为 `num[0:i]`中的最大和连续子数组, 因为这样定义, 子问题就无法相互递推了

这样, 我们就能自然地写出 `状态转移过程`: 此时, $dp[i] = max(num[i], num[i]+dp[i-1])$

> 这里的意思是, 因为 `dp[i]` 一定是以 `num[i]` 结尾的, 所以, `dp[i]`就有两个选择, 要么是 `dp[i-1]`拼接上 `num[i]`, 要么是 `num[i]` 本身. 这两者中选择最大的.
>
> 因为题目没有要求输出最大和连续子数组, 只要求计算最大和, 因此, 为了方便比较, 我们定义 `dp` 中直接保存 最大连续子数组的和.

根绝这个`dp` 数组定义, 很容易写出基础条件是 `dp[0] = nums[0]`, `dp`数组的其他元素处于未计算状态, 可以初始化为极小值, 不过这里`dp[i]`由`dp[i-1]`推出, 因此未计算元素的初始化值其实不重要(会在循环中覆盖), 下面为了简便初始化为0

同时也可以知道, `dp` 数组的长度等于 `nums` 的长度, 迭代从 1 开始.

因此有:

```python
dp[0] = nums[0]
for i in range(1,len(nums)):
    dp[i] = max(nums[i], dp[i-1] + nums[i])
```

写出形式化的状态转移方程:

$$
dp[i]=
\begin{cases}
nums[0],& \quad i=0 \\
max(nums[i], dp[i-1]+nums[i]),& \quad i>0
\end{cases}
$$

**这样计算完之后, dp 数组中保存了每个结尾的最大和, 而本题要求计算整个数组中的最大和, 因此再遍历一遍 dp 数组即可.**

```python
# python 中可以使用 max 函数, 时间复杂度等同于遍历, O(n)
max_sum = max(dp)
```

合并以上, 得出完整的解法:

```python
class Solution(object):
    def maxSubArray(self, nums):
        # 定义 dp[i]为以 nums[i]为结尾的最大连续子数组之和
        if len(nums)==1:
            return nums[0]
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            dp[i] = max(nums[i], dp[i-1] + nums[i])
        # dp数组状态的定义不是题目中的问题的定义，因此不能直接将最后一个状态返回回去!!
        return max(dp)
```

很明显, 这里的 `dp` 数组的空间占用还可以进一步优化. 实际只需要两个元素(`previous`和`current`), 同时记录一个最大值即可, 优化的实现如下:

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        n = len(nums)
        prev = maxSum = nums[0]
        for i in range(1, n):
            curr = max(prev + nums[i], nums[i])
            maxSum = max(maxSum, curr)
            prev = curr
        return maxSum
```

##### 分析(分治法)

分治法类似于「线段树求解最长公共上升子序列问题」的 `pushUp` 操作。

#### [152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)

> 难度中等2005
>
> 给你一个整数数组 `nums` ，请你找出数组中**乘积最大的非空连续子数组**（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。
>
> 测试用例的答案是一个 **32-位** 整数。
>
> **子数组** 是数组的连续子序列。
>
> **示例 1:**
>
> ```
> 输入: nums = [2,3,-2,4]
> 输出: 6
> 解释: 子数组 [2,3] 有最大乘积 6。
> ```

##### 分析

本题和 **53. 最大子数组和** 非常相似, 不同之处是这里是在求 乘积 最大的连续子数组. 在 求最大子序和 的时候, 我们使用 $dp[i] = max(nums[i], dp[i-1]+nums[i])$ 来更新 `dp` 数组.

这里如果我们直接套用这个方式, $dp[i] = max(nums[i], dp[i-1] \times{nums[i]})$ 的话, 会出现问题! 这是因为计算乘积的时候可能出现 **符号翻转** . 例如 输入样例 `[-2, 3, -4]`, 如果直接套用上面的公式, 得到的最大`dp`是 `3`, 但是正确结果是 `24 = -2*3*-4`. 因此这里需要做出一点改动, *在记录最大乘积的时候同时记录最小乘积, 以考虑可能出现的额符号翻转情况* (**当出现符号翻转时, 之前的最小值可能变为新的最大值, 同样, 之前的最大值也可能变为新的最小值**)

定义 `dp_max[n]` 为 以`nums[n]`为结尾的乘积**最大**的连续非空子数组; `dp_min[n]` 为 以`nums[n]`为结尾的乘积**最小**的连续非空子数组. 则有:

初始化为:

$$
dp_{max}[0] =  nums[0] \\
dp_{min}[0] =  nums[0]
$$

递推公式:

$$
dp_{max}[n] = \max\{ dp_{max}[n-1]\times{nums[n]},\quad dp_{min}[n-1]\times{nums[n]},\quad nums[n] \} \quad,n>1
$$


$$
dp_{min}[n] = \min\{ dp_{max}[n-1]\times{nums[n]},\quad dp_{min}[n-1]\times{nums[n]},\quad nums[n] \} \quad,n>1
$$

```python
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        n = len(nums)
        # 和题目53一样, 这里的未计算值初始化值其实不重要, 因为会在计算中被覆盖
        dp_max = [0 for _ in range(n)]
        dp_min = [0 for _ in range(n)]
        dp_max[0] = nums[0]
        dp_min[0] = nums[0]
        for i in range(1, n):
            dp_max[i] = max(
                dp_max[i-1]*nums[i], dp_min[i-1]*nums[i], nums[i]
            )
            dp_min[i] = min(
                dp_max[i-1]*nums[i], dp_min[i-1]*nums[i], nums[i]
            )

        return max(dp_max)
```

#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

> 给你一个整数数组 `nums` ，找到其中**最长严格递增子序列**的长度。
>
> 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。(本题*不要求子序列连续*)
>
> 示例 1：
>
> ```
> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
> ```

> **二分查找法**可以得到时间复杂度为 $O(n\log{n})$ 的更佳解法.

##### 分析(动态规划)

本题和上一个题目**#53**类似, 依然是一个单序列的问题, 从头迭代到结束就行, 因此也不需要使用双指针. 故我们直接套用 `dp` 数组 定义如下: **`dp[i]` 是以 `nums[i]` 结尾的最长严格递增子序列的长度**

然后确定 `dp` 数组**长度**: 由定义可知, 这里的数组长度等于`nums`的长度.

然后确定 `dp` 数组的**初始化方式**: 这里和**#53**不同, *由于每个字符本身就是一个长度为1的递增序列, 因此这里`dp`数组应该 **全部初始化为 1***, 这里也包含了边界情况, 即 `n==0` 的时候.

接下来需要确定状态转移过程, 也就是如果已知 `dp[i-1]`, 怎么推导出 `dp[i]` ?

本例需要确定 以 `nums[i]` 的位置结尾的递增子序列的最大长度. 这里可想, 对于 `nums[i]`之前的数字, 如果其小于 `nums[i]`, 则可以和 `nums[i]` 构成一个递增子序列, 由于 `nums[i]`前面结尾的最大递增长度都已经确定了, 这里只需要`+1`就行, 然后取`max`就可以. 但是由于 `nums[i]` 前面可能小于 `nums[i]` 的数字不止一个, 所以这里还需要套一层**迭代**.

> 本题的状态转移处理和 **#322. 零钱兑换** 有点类似, 都需要一个内层循环寻找所有的可能取值.

至此, 我们可以写出如下的形式化的状态转移过程:

$$
dp[n] = \
\begin{cases}
\begin{align}
1,&\quad n = 0;\\
max\{dp[i]+1|i \in \{0,\dots,n-1\} \land nums[i]<nums[n]\},&\quad n\ge{1}.
\end{align}
\end{cases}
$$

这样, 迭代完成之后, `dp` 中就保存了每个位置结尾的最大递增子序列的长度, 题目要去返回其中的最大值, 直接`max`即可

进而可以写出代码实现如下:

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        """ 最长递增子序列
        """
        # `dp[i]` 是以 `nums[i]` 结尾的最长严格递增子序列的长度
        dp = [1] * len(nums)
        # 从下标1开始迭代:
        for i in range(1, len(nums)):
            # 寻找在nums[i]之前的所有小于nums[i]的数字
            for j in range(0, i):
                # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j] + 1)
        # 迭代完成之后, dp 中就保存了每个位置结尾的最大递增子序列的长度,
        # 题目要去返回其中的最大值, 直接max即可, 也可以在遍历时记录一个最大值变量
        return max(dp)
```

##### 分析(**二分查找**解法)

<todo>

#### [673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)

> 难度中等724
>
> 给定一个未排序的整数数组 `nums` ， *返回最长递增子序列的个数* 。
>
> **注意** 这个数列必须是 **严格** 递增的。
>
> **示例 1:**
>
> ```
>输入: [1,3,5,4,7]
> 输出: 2
> 解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
> ```

##### 分析(动态规划)

本题是「[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)」的进阶版本. 在 「[300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)」中只需要计算最长的递增子序列的长度即可, 而在本题中不仅需要计算最长的递增子序列的长度, 更要返回等于最长长度的子序列的数量. 因此, 容易想到在*300 最长递增子序列*的解法上做一定的修改, 同步记录子序列的数量.

类似*300 最长子等子序列*, 这里定义 `dp[i]` 是以 `nums[i]` 结尾的最长严格递增子序列的**长度**, 此外, 定义 `cnt[i]` 是以 `nums[i]` 结尾的最长严格递增子序列的**个数**.

这里的递归公式和题目*300* 一致, 只不过需要*特别注意`cnt`的更新策略*. 仿照题目*300*, 实现如下:

```python
class Solution:
    def findNumberOfLIS(self, nums: List[int]) -> int:
        # 定义dp[i]为以nums[i]结尾的最长递增子序列的长度
        dp = [1] * len(nums)
        # 定义cnt[i]为以nums[i]结尾的最长递增子序列的数量
        cnt = [1] * len(nums)
        # 记录最大序列长度 
        max_len = 1
        # 记录长度等于最大长度的序列数量
        res = 1
        # 从下标1开始迭代:
        for i in range(1, len(nums)):
            # 寻找在nums[i]之前的所有小于nums[i]的数字
            for j in range(0, i):
                # 如果要求非严格递增，将此行 '<' 改为 '<=' 即可。
                if nums[j] < nums[i]:
                    if dp[j] + 1 > dp[i]:
                        dp[i] = dp[j] + 1
                        # 最长子序列是以nums[j]+nums[i]结尾
                        # 此时以nums[i]结尾的子序列个数和以nums[j]结尾的子序列数量相同
                        cnt[i] = cnt[j]
                    elif dp[j] + 1 == dp[i]:
                        # 此时说明以nums[i]结尾的子序列多了一种可能,
                        # 这种新的可能是以nums[j]+nums[i]结尾
                        # 此时以nums[i]结尾的序列总数需要加上这种新的可能的数量(cnt[j])
                        cnt[i] += cnt[j]
            # 一种常见的错误认知就是: 先找到dp中取值最大时的索引 max_i, 然后返回 cnt[max_i]
            # 这是因为可能存在多个长度相同的最大序列, 而他们的结尾不同.
            # 正确的方式如下:
            if dp[i] == max_len:
                res += cnt[i]
            elif dp[i] > max_len:
                max_len = dp[i]
                res = cnt[i]
        
        return res
```

##### 分析(**二分查找**解法)

<todo>

#### [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

> 难度简单357
>
> 给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。
>
> **连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。
>
>
>
> **示例 1：**
>
> ```
> 输入：nums = [1,3,5,4,7]
> 输出：3
> 解释：最长连续递增序列是 [1,3,5], 长度为3。
> 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
> ```

> 本题是一个简单题目, 可以用 *动态规划* 解决, 时间复杂度: $O(n)$, 空间复杂度 $O(1)$ (优化后);
>
> 本题也可以用**贪心**思想解决, 时间复杂度: $O(n)$, 空间复杂度 $O(1)$; 贪心解法在本题中更直观.

##### 分析(动态规划解法)

本题和*300最长递增子序列* 非常相似, 只不过本题的要求更加严格, 要求序列元素在原数组中*必须连续*的, 这实际上简化了题目要求.

考虑在*300最长递增子序列* 题目中, 当$n>0$时, 有如下的递推公式:

$$
dp[n] = max\{dp[i]+1|i \in \{0,\dots,n-1\} \land nums[i]<nums[n]\}
$$

注意这个递推公式中有一个循环判断($i \in \{0,\dots,n-1\}$), 这是因为*300最长递增子序列*不要求子序列连续, 所以要判断 $n$ 之前的所有元素是不是都符合要求. 而本题要求必须连续, 因此实际上只需要判断上一个元素是否满足要求即可 (只要比较`nums[i]`与`nums[i - 1]`，而不用去比较`nums[j]`与`nums[i]`（`j`是在`0`到`i`之间`遍历`）), 因此本题的递归公式如下:

$$
dp[n] = \
\begin{cases}
\begin{align}
1 &\quad,\text{n = 0;}\\
dp[n-1]+1 &\quad, n \ge 1 \land dp[n-1] < dp[n].\\
1 &\quad, n \ge 1 \land dp[n-1] \ge dp[n].
\end{align}
\end{cases}
$$

具体的实现如下

```cpp
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 1:
            return n
        # 定义dp[n]为以nums[n]结尾的最长连续递增序列长度
        dp = [1] * n
        for i in range(1, n):
            if nums[i-1] < nums[i]:
                 dp[i] = dp[i-1] + 1
        return max(dp)
```

明显上面解法的空间复杂度还可以进一步优化, 优化后空间复杂度为 $O(1)$

##### 分析(**贪心**解法)

本题用贪心算法解决更简单直观, 且空间复杂度更低.

```python
class Solution:
    def findLengthOfLCIS(self, nums: List[int]) -> int:
        max_len = 0
        n = len(nums)
        if n <= 1:
            return n
        s = 0
        for i in range(1,n):
            if nums[i] > nums[i-1]:
                pass
            else:
                max_len = max(max_len, i-s)
                s = i
        max_len = max(max_len, n-s)
        return max_len
```

#### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

> 给你一个二维整数数组 `envelopes` ，其中 `envelopes[i] = [wi, hi]` ，表示第 `i` 个信封的宽度和高度。
>
> 当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。
>
> 请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。
>
> 注意：不允许旋转信封。
>
>
> 示例 1：
>
> ```
> 输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
> 输出：3
> 解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
> ```

##### 分析

可以先按照 `宽 wi`排序(升序), 然后对排序后的序列中的 `高 hi`取最大递增子序列, 这样也就转化为了 [#300](##300)

0. **问题预处理**: 对`envelopes`按照元素 0(即`wi`)升序排列. 然后对排序后的`envelopes`的元素 1 的序列取 最大递增子序列.

   > **注意**: 排序得到的序列的元素[0]可能有相同的, 例如:
   >
   > `[(1,1),(4,5),(4,6)]`
   >
   > **其中 (4,5) 不能放到 (4,6), 这一点需要在后面的状态转移中规避.**

1. **定义 dp 数组**: 单个序列的子序列问题, 定义 dp 数组的 `dp[i]` 表示 **以 s[i]结尾的子串的最大递增子序列的长度**. 因此, dp 数组的长度为`n`.

2. **确定初始化**: 一开始全部初始化为 1(每个数字自身就构成一个递增子序列)

3. **确定状态转移**: 如果已知 `dp[n-1]`(以及它前面的所有dp 值), 如何得到 `dp[n]`? 这要看 `envelopes[n][1]` 和前面的值的关系:

   对于`envelopes[n][1]`之前的所有数字, 即 ${envelopes[i][1]|i\in\{0,…,n-1\}}$.

   如果 `envelopes[i][1]<envelopes[n][1]`, 而且**为了避免宽度相同**, 还要求 `envelopes[i][0]<envelopes[n][0]`, 则 `dp[n] = max(dp[n], dp[i]+1)`;

   否则, 维持 `dp[n]`不变.

   这和 [#300](##300) 的状态转移过程几乎一样.

4. **确定迭代方向**: 从 1 开始, 向前迭代, 到 n-1 为止.

代码实现如下:

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        # 预处理, 按照元素 0 排序(升序)
        envelopes = sorted(envelopes, key=lambda i: i[0])
        # 初始化 dp 数组:
        dp = [1] * len(envelopes)
        # 迭代:
        for i in range(1, len(envelopes)):
            # 找到所有前面的数字:
            for j in range(0, i):
                # 重要: 这里判断大小的时候, 既要限制长度, 也得限制宽度 !!!
                if (
                    envelopes[j][1] < envelopes[i][1]
                    and envelopes[j][0] < envelopes[i][0]
                ):
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

这个方案时间复杂度为 $O(n^2)$, 提交之后发现超时了. 虽然 $O(n^2)$ 的解法不是最佳方法, 但是也不应该超时的, 分析 case 发现, 有一个测试用例中存在很多宽度相同的子串, 上述解法中为了避免宽度相同使用了两个 if 判断, 两个判断明显慢了很多. 分析发现, 我们**可以在排序时, 按照宽度升序排列, 同样宽度的按照长度降序排列**, 这样就可以省去第二个 if 判断.

> 要让排序时按照元素 0 升序,元素 1 降序, 可以写作:
>
> `sorted(envelopes, key=lambda i: (i[0], -i[1]))`

例如: 原先的排序可能得到如下结果, `(-1, 2), (-1, 89), (-1, 100)` 这样就必须做两个 if 判断; 新的排序方式得到的是 `(-1, 100), (-1, 89), (-1, 2)`, 这样一个判断就可以了.

改进后的方案为:

```python
class Solution:
    def maxEnvelopes(self, envelopes: List[List[int]]) -> int:
        # 预处理, 按照元素 0 升序, 元素 1 降序
        envelopes = sorted(envelopes, key=lambda i: (i[0], -i[1]))
        # 初始化 dp 数组:
        dp = [1] * len(envelopes)
        # 迭代:
        for i in range(1, len(envelopes)):
            # 找到所有前面的数字:
            for j in range(0, i):
                # 判断大小 只需要要限制长度即可:
                if envelopes[j][1] < envelopes[i][1]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
```

> 注意, 这个题目动态规划( $O(n^2)$ )不是最佳解法, **二分查找法**可以得到时间复杂度为 $O(n\log{n})$ 的更佳解法.

#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。
>
> 给定一个代表每个房屋存放金额的**非负整数数组**`nums`，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。
>
> **示例 1：**
>
> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> ```

##### 分析

这依然是一个序列中寻找符合条件的子序列的问题, 而且当前房屋偷还是不偷, 取决于前面的状态, 因此符合动态规划的特点, 可以用动态规划求解.

类似上面的题目, 这里定义`dp[n]`为: 以`nums[n]`为结尾的符合条件(即没有两个相邻的元素)的子序列的**最大和**.

此时关键是写出递推公式, 关键就是确定`选择`. 这里的`选择` 就是 `nums[i]`房间 偷还是不偷:

> **说明**: 当递归公式不好想时, 要仔细分析什么复合动态规划中的 `状态` 和 `选择`, 以及不同的`选择`会引起`状态`怎么改变

+ 如果偷`i`号房间, 那么此时 `dp[i] = dp[i-2] + nums[i]`. 注意这里不用`dp[i-1]`,这里因为如果决定偷`i`号房间, 则可能不能同时偷`i-1`号房间;
+ 如果不偷`i`号房间, 那么此时 `dp[i] = dp[i-1]`, 这容易理解, 因为不偷`i`号房间的话, 当前最大金额就是考虑`i-1`号房间时的金额(至于是否偷了`i-1`则不一定)

这里是在求最大值, 因此直接取上述两种情况的最大值即可, 故此, 我们得到如下的递推公式: $dp[i] = max\{dp[i-2]+nums[i],\ dp[i-1]\}$ .

接下来考虑初始化, 由上述递推公式可以看出, 递归依赖`dp[0]`和`dp[1]`两个初始值. `dp[0]` 一定等于 `nums[0]`; 而 `dp[1]` 则应该是 `nums[0]`和`nums[1]`的最大值.

故:

$$
dp[n] =
\begin{cases}
nums[0] &,\quad n=0 \\
\max{(nums[0], nums[1])} &,\quad n=1 \\
\max{(dp[n-2]+nums[n],\ dp[n-1])} &,\quad n>1
\end{cases}
$$

实现如下:

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n==1:
            return nums[0]
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(
                dp[i-2] + nums[i],
                dp[i-1]
            )
        return max(dp)
```

很明显, 上面实现的空间复杂度还可以进一步优化

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

> 难度中等1268
>
> 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。
>
>  
>
> **示例 1：**
>
> ```
> 输入：nums = [2,3,2]
> 输出：3
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
> ```

##### 分析

本题和上一题 *198 打家劫舍* 非常相似, 唯一差别在于, 本题中的房间序列构成了一个首尾相连的`环`, 限制条件还是一样: 即不能同时偷两个相邻的房间. 和上一题的解答方式的唯一不同之处就是, 我们需要额外确保**不能出现首元素和尾元素同时被选中的情况** (因为其他的情况已经在上一题的递推公式中考虑到了).

观察上一题的递归公式:

$$
dp[n] =
\begin{cases}
nums[0] &,\quad n=0 \\
max\{nums[0], nums[1]\} &,\quad n=1 \\
max\{dp[n-2]+nums[n],\ dp[n-1]\} &,\quad n>1
\end{cases}
$$

想要在上面的递归公式中直接加入: **不能出现首元素和尾元素同时被选中的约束** 并不容易. *这一约束很难直接写到上面的公式里, 也不好通过条件判断做分支处理.*

这里需要做一个转换, 现在考虑两种情况:

+ 一种是只包含首个元素, 剔除尾元素, 此时可用通过上一题的解法求出此时的最大金额;

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230216151311.png" alt="image-20230216150647615" style="zoom:50%;" />

+ 一种是只包含尾部元素, 剔除首元素, 此时可用通过上一题的解法求出此时的最大金额;

  <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230216151424.png" alt="image-20230216151423958" style="zoom:50%;" />

此时对上述两种情况下得到的最大值取`max`, 结果即为成`环`后的最大金额. 这是因为, **上述两种情况除了没有考虑首尾可能同时被偷取的情况外, 其他所有情况都考虑到了, 而本题恰恰要求首尾不能同时偷取**, 因此上述两种情况的最大值即为本题的答案.

按照上述分析, 只需要将上一题 *198 打家劫舍* 的答案改为一个方法, 然后分别输入`nums`的两个切片, 得到两个结果, 然后取最大值即可:

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        value_a = self.rob_sublist(nums[1:])
        value_b = self.rob_sublist(nums[:-1])
        return max(value_a, value_b)
    
    def rob_sublist(self, nums: List[int]) -> int:
        n = len(nums)
        if n==0:
            return 0
        if n==1:
            return nums[0]
        dp = [0 for _ in range(n)]
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(
                dp[i-2] + nums[i],
                dp[i-1]
            )
        return max(dp)
```

## 两个序列问题

两个序列的情况一般都是**双指针**:

+ `dp` 数组定义为 `dp[i][j]为s1[0,i)和s2[0,j)的最XX的子序列的xx`; (注意不包含 `s1[i]` 和 `s2[j]`).
+ 数组长度一般为 $(n+1) \times (m+1)$
+ 一般 0 是边界情况, 两个指针都从 1 开始迭代
+ 例子: **#1143** 最长公共子序列 , **#72** 编辑距离

#### [718. 最长重复子数组](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

难度中等855

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

##### 分析

> **子序列默认不连续，子数组默认连续**

第一步确定`dp`数组以及下标的含义: `dp[i][j]` 为 `nums1[0,i-1]` 和 `nums2[0,j-1]` 的 **最长公共后缀**的长度.

> 这里做了一个转换, 定义 `dp[i][j]`为 **最长公共后缀**的长度, 从前向后遍历两个字符串. (也可以定义为前缀, 但是遍历需要从后向前遍历). 计算完成后, 对  `dp[i][j]` 取最大值即为 **公共的长度最长的子数组的长度**

根据这个定义, 数组的长度应该定义为 `[n+1, m+1]`, n 和 m 分别为两个字符串的长度. 数组一开始都初始化为 0 ;

根据定义, 两个指针分别指向两字符串的尾部(遍历时从1开始), `dp[i][j]`的值取决于之前的值和当前两个指针指向的字符.

+ 如果两个指针指向的字符相等:  则当前指针指向的字符是重复子数组的一部分, 此时 `nums[0, i)` 和 `nums[0, j)`的**最长公共后缀** 就等于 `nums[0, i-1)` 和 `nums[0, j-1)`的**最长公共后缀**的长度 加1, 即 `dp[i][j] = 1 + dp[i-1][j-1]`
+ 如果两个指针指向的字符不相等:  则此时 `nums[0, i)` 和 `nums[0, j)`的**最长公共后缀** 肯定为零

遍历完两个字符串后, 我们得到了 所有 `nums[0, i)` 和 `nums[0, j)`的**最长公共后缀**长度, 其为一个二维数组, 从这个数组中取最大值, 即为 *两个数组中 **公共的** 、长度最长的子数组的长度*

```python
class Solution:
    def findLength(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        m = len(nums2)
        # `dp[i][j]` 为 `nums1[0,i-1]` 和 `nums[0,j-1]` 的 **最长公共后缀**的长度.
        # 故 dp数组的维度为 (n+1)*(m+1)
        dp = [ [0] * (m+1) for _ in range(n+1) ]

        max_value = 0
        for i in range(1, n+1):
            for j in range(1, m+1):
                # 注意这里需要 -1
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = 1 + dp[i-1][j-1]
                    max_value = max(max_value, dp[i][j])
                else:
                    dp[i][j] = 0
        return max_value
```

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

> 给定两个字符串 `text1` 和 `text2`，返回这两个字符串的**最长公共子序列的长度**。
>
> 一个字符串的 **子序列** 是指这样一个新的字符串：它是**由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串**。
> 例如，`ace` 是 `abcde` 的子序列，但 `aec` 不是 `abcde` 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
>
> 若这两个字符串没有公共子序列，则返回 0。

##### 分析

定义 `dp` 数组如下: **定义 指针`i`指向字符串`s1`, 指针`j`指向字符串`s2`,  则 `dp[i][j]`为`s1[0,i)`和`s2[0,j)`的最大公共子序列的长度.**

根据这个定义, 数组的长度应该定义为 `[n+1, m+1]`, `n` 和 `m` 分别为两个字符串的长度.

数组一开始都初始化为 0 ;

此时, `边界情况`(基础情况)就是当`i`或者`j`为 0 时, 此时, `s1`或者`s2`为一个空串( Python`s1[0:0)`是一个空串), 此时最大公共子串长度肯定为 0.

迭代填充 `dp` 数组的时候**从 1 开始** (自底向上, 0 是边界情况).

此时两个指针位置的字符相互比较:

+ 如果**两个字符相等**, 说明这个字符在公共子序列中, **此时公共子序列的长度等于 当前两指针前的字符串的公共子序列的长度+1**, 此时**同时向前移动两个指针**(代表`选择`); 即 `dp[i][j] = 1 + dp[i-1][j-1]`

+ 如果**两个字符不相同**, 则说明至少其中一个不在公共子序列内, **此时公共子序列的长度等于 当前两指针前的字符串的公共子序列的长度** , 同时此时需要移动指针:

  + 要么向前移动指针 `i`;
  + 要么向前移动指针`j`;
  + 要么同时向前移动指针`i`和`j`;

  **如何判断该做出哪一种移动**, 则需要按照题目的要求, 以最后的**序列长度最大**为选择条件;

形式化状态转移为:

$$
dp[i][j]=
\begin{cases}
 0,& \quad i=0 \lor j=0\\
 1+dp[i-1][j-1],& \quad s1[i]==s2[j]\\
 max\left(
  \begin{align*}
   &dp[i-1][j]\\
   &dp[i][j-1]\\
   &dp[i-1][j-1]
  \end{align*}
 \right),& \quad s1[i]\not=s2[j]
\end{cases}
$$

另外, 注意这里当 `s1[i]!=s2[j]`的第三种选择`dp[i-1][j-1]`, 实际包含在前两种选择里(这是**因为两个指针都移动肯定比其中一个指针移动短**), 所以在计算的时候可以省去不写.

```python
class Solution(object):
    def longestCommonSubsequence(self, text1, text2):
        # 定义 dp[i][j] 为 字符串s1[0, i) 和 字符串 s2[0, j) 的最长序列长度
        # 初始化 dp 数组， 值为 0
        m = len(text1)
        n = len(text2)
        dp = [[0] * (n+1) for _ in range(m+1)]
        # 自底向上填充 dp 数组
        for i in range(1, m+1):
            for j in range(1, n+1):
                if text1[i-1] == text2[j-1]:
                    # 对应位置字符相同， 可以同时去除最后的字符，看前面的结果
                    # 同时最大长度+1
                    dp[i][j] = 1 + dp[i-1][j-1]
                else:
                    dp[i][j] = max(
                        [
                            dp[i-1][j], # 前移 i
                            dp[i][j-1]  # 前移 j
                        ]
                    )
        return dp[-1][-1]  
```

注意, 由于是**自底向上**, 因此都是通过底层的来推顶层的, 所以是 `dp[i][j] = 1 + dp[i-1][j-1]`, 而是不是`dp[i][j] = 1 + dp[i+1][j+1]` (后一种是自顶向下, 是递归写法)

这样就填充完了 `dp` 数组, 此时最后的位置, 即`dp[-1][-1]`就记录了两个字符串的最大子序列长度. 因此直接返回二维数组的最后元素就行.

#### 583. [两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings)

> 给定两个单词 *word1* 和 *word2*，找到使得 *word1* 和 *word2* 相同所需的最小步数，每步可以**删除**任意一个字符串中的一个字符。

> 注意: 和编辑距离不同, 这里可以对两个字符串操作, 而且只可以删除.
>

> **tag:** **两个序列的子序列最值问题**; 双指针/动态规划; 二维 `dp` 数组; `dp[i][j]`为`s1[0,i)`和`s2[0,j)`的最XX的子序列的xx; 0 是边界情况, 从 1 开始迭代

##### 分析

本问题**等价于求两个字符串的 最长公共子序列**, 一旦计算得到`最长公共子序列`, 则 **删除的步数=两个字符串的长度之和 - (最长公共子序列的长度*2)**

即:

```python
  def minDistance(self, word1, word2):
    # longestCommonSubsequence 是之前定义的最长公共子序列长度函数
        x = self.longestCommonSubsequence(word1,word2) # 代码见题 1143
        return len(word1) + len(word2) - x * 2
```

#### 712. [两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

> 给定两个字符串`s1, s2`，找到使两个字符串相等所需删除字符的ASCII值的最小和。
>
> 注意:
>
> + `a`的 ascii 值为 97, `z`的 ascii 值为 122;
>
> + 本题所有字符串中的字符ASCII值在`[97, 122]`之间。

> **tag:** **两个序列的子序列最值问题**; 双指针/动态规划; 二维 dp 数组; `dp[i][j]`为`s1[0,i)`和`s2[0,j)`的最XX的子序列的xx; 0 是边界情况, 从 1 开始迭代

> **问题转化**:
>
> ​ 和 583 有点类似, 但是这里不能直接转化为 求两个序列的拥有最大长度的公共子序列(返回长度), 而是应该求 两个序列的**拥有最大ASCII之和的公共子序列(返回 ASCII 和)**. 然后**两个序列的 ASCII 总和 减去两倍的子序列ASCII和**就是答案.

> **提示**:
>
> Python 内置的 `ord` 函数可以返回一个字符的 ASCII 值.

##### 分析

对 **1143. 最大公共子序列长度** 略加改造既有:

```python
class Solution:
    def max_ascii_sum_common_subsequence(self, text1, text2):
       """ 寻找具有最大 ASCII 和 的 公共子序列
       如果找到, 则返回 ASCII 和; 
       如果没有找到, 则返回 0.
       注意, 本例中所有字符的 ASCII 值都>=97, 因为正常情况下不会返回 0
       """
        # 定义 dp[i][j] 为 字符串s1[0, i) 和 字符串 s2[0, j) 的最长序列长度
        # 初始化 dp 数组， 值为 0
        m = len(text1)
        n = len(text2)
        if m == 0 or n == 0:
            return 0
        # 依然初始化为 0
        dp = [[0] * (n+1) for _ in range(m+1)]
        # 自底向上填充 dp 数组
        for i in range(1, m+1):
            for j in range(1, n+1):
                if text1[i-1] == text2[j-1]:
                    # 对应位置字符相同， 可以同时去除最后的字符，看前面的结果
                    # 同时最大长度+1
                    # 注意: Python ord 函数可以获取一个字符的 ASCII 值
                    # 注意, 这里我们的目的是找最大ASCII之和的公共子序列,
                    # 因此不能+1, 而应该+相同字符的 ASCII 值
                    dp[i][j] = ord(text1[i-1]) + dp[i-1][j-1]
                else:
                    dp[i][j] = max(
                        [
                            dp[i-1][j],
                            dp[i][j-1]
                        ]
                    )
        return dp[-1][-1]
    
    def minimumDeleteSum(self, s1, s2):
       # 注意: Python ord 函数可以获取一个字符的 ASCII 值
        s1_ascii = sum([ord(i) for i in s1])
        s2_ascii = sum([ord(i) for i in s2])
        x = self.max_ascii_sum_common_subsequence(s1, s2)
        # 如果 x 为 0, 则没有公共子序列, 需要全部删除
        # 如果不是 0, 则删除对应的差值即可
        return s1_ascii + s2_ascii - x * 2
```

#### [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/)

> 难度中等413
>
> 在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。
>
> 现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：
>
> + `nums1[i] == nums2[j]`
> + 且绘制的直线不与任何其他连线（非水平线）相交。
>
> 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。
>
> 以这种方法绘制线条，并返回可以绘制的最大连线数。
>
> **示例 1 :**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230217181031.png" alt="image-20230217181031741" style="zoom: 25%;" />
>
> ```
> 输入：nums1 = [1,4,2], nums2 = [1,2,4]
> 输出：2
> 解释：可以画出两条不交叉的线，如上图所示。 
> 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交
> ```

##### 分析

多看几个示例, 即可以得出结论, **不相交的线的数量等于 两个数组的 最大公共子序列的长度**, 因此直接套用 *1143 最长公共子序列* 的解法即可:

```python
class Solution:
    def maxUncrossedLines(self, nums1: List[int], nums2: List[int]) -> int:
        n = len(nums1)
        m = len(nums2)
        dp = [ [0] * (m+1) for _ in range(n+1)]

        for i in range(1, n+1):
            for j in range(1, m+1):
                if nums1[i-1] == nums2[j-1]:
                    dp[i][j] = dp[i-1][j-1] + 1
                else:
                    dp[i][j] = max(
                            dp[i-1][j],
                            dp[i][j-1]
                            )
        return dp[-1][-1]
```

#### 72. [编辑距离](https://leetcode-cn.com/problems/edit-distance/)

> 给你两个单词 `word1` 和 `word2`，请你计算出将 `word1` 转换成 `word2` 所使用的最少操作数 。
>
> 你可以对一个单词进行如下三种操作：
>
> + **插入**一个字符
> + **删除**一个字符
> + **替换**一个字符

##### 分析

参照 1143. 中的说明:

> **解决两个字符串的动态规划问题，一般都是用两个指针`i,j`分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模**
>
> 注意这里说指向尾部是从分解子问题的角度说的, 迭代的时候可能还是从 0 开始填充数组(因为边界条件一般是 0 或者 1, 所以应该先计算底层, 再推高层)

先**从将原问题分解为子问题的角度出发**, 这里设置两个指针 `i` 和 `j` , 分别指向两个字符串的**尾部**, **从头往前移动, 逐个对比字符, 做出动作选择**.

> 这里的动作有四种: **插入, 删除, 替换, 什么都不做**

+ 如果`s1[i] == s2[j]`, 则: 什么都不做, 同时向前移动两个指针;
+ 如果不相等, 则选择其余三种动作, 同时选择移动指针的策略.

因此, 关键就是如果选择三种其余动作, 这里类似 *1143 最长公共子序列* 中选择动作的情况, 全部计算, **使用最值取筛选**即可(实际是暴力计算, 但是没有其他更好的办法)

接下来就需要定义 `dp` 数组, 根据上面的分析, 我们定义: `dp[i][j]`是以 `s1[i]` 结尾的字符串`s1[0:i]` 和以`s2[j]`结尾的字符串`s2[0:j]`的编辑距离(**最小操作数**)

因此, 状态转移过程为:

+ `IF s1[i] == s2[j]`: `dp[i][j] = dp[i-1][j-1]` , 此时只需向前移动指针就好 (**编辑操作数不变**);

+ `IF s1[i] != s2[j]`: 基于 **最小化操作数**的原则选择如下操作之一:

  + `插入`: 指在其中一个位置(假设为 `i`)插入一个新字符(和另外一个指针对应的字符相同), 此时位置`i`变为了位置`i'`, 且 `i' = i+1`, 表示新插入的字符. 此时 指针`i'` 和指针 `j`的字符一致, 因此应该同时向前移动, 且 编辑操作数+1, 但是注意, `i'`向前移动变为了`i`, 等于前后位置不变, 只有 `j`的位置变了.

    因此此时的动作就是: `= dp[i][j-1] + 1` 或者 `= dp[i-1][j] + 1` (对应两个可能的插入位置)

  + `删除`: 指在其中一个位置(假设为`i`)删除当前字符, 此时, 只需要向前移动指针`i`即可, 同时 编辑操作数+1, 另外一个指针不变.

    因此, 此时的动作就是: `= dp[i-1][j] + 1` 或者 `= dp[i][j-1] + 1` (对应两个可能的删除位置)

  + `替换`:指在其中一个位置替换当前字符为一个新字符(和另外一个指针对应的字符相同), 此时两个指针位置都不变, 对应字符变为同样的字符, 因此, 此时应该同时前移两个指针, 同时 编辑操作数+1.

    因此此时的动作是: `= dp[i-1][j-1] + 1`

  从上面的分析可以看出, **`插入`和`删除`实际的动作等价**, 因此, 合并所有动作可以写为一下的形式:

  ```python
  dp[i][j] = min( # 最小化操作数
   dp[i][j-1] + 1, # 插入或者删除
    dp[i-1][j] + 1, # 插入或者删除
    dp[i-1][j-1] + 1 # 替换
  )
  ```

根据上面的分析, 可以看出本例的最终解决方式和 1143. 非常相似.

除此之外, 我们还需要明确**边界情况**:

+ 如果其中一个指针`i`指向`-1`(超出字符串范围), 则表示另一个指针`j`指向的位置和前面的字符需要全部删除. 此时 `增加的操作数 = j+1` (加 1 是因为指针从 0 开始计数). 同样, 当`j`指向 `-1`的时候情况类似.

通过对上述的边界情况的分析, 可以发现如果使用 -1 作为字符串超界标记, 不是很方便 (因为编程语言的数组下标都是从 0 开始). 因此, 我们统一将两个指针迁移一个位置, 并修改 dp 数组定义如下:

`dp[i][j]`是以 `s1[i-1]` 结尾的字符串`s1[0:i)` 和以`s2[j-1]`结尾的字符串`s2[0:j)`的编辑距离(最小操作数)

综合得到代码如下:

```python
class Solution(object):
    def minDistance(self, word1, word2):
        # 定义:
        # `dp[i][j]`是 字符串`s1[0:i-1]` 和 字符串`s2[0:j-1]`的编辑距离(最小操作数)
        # 确定字符串长度
        m = len(word1)
        n = len(word2)

        # 初始化 dp 数组， 值为 0
        # 为什么+1, 是因为数组下标现在从 1 开始了 (0 是边界特殊位置)
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # 填充边界条件: 非常重要
        # 边界就是当其中一个指针 为 0 的时候
        for j in range(1, n + 1):  # 当 i 为 0 时
            dp[0][j] = j
        for i in range(1, m + 1):  # 当 j 为 0 时
            dp[i][0] = i
        # 注意 dp[0][0] 应该是 0, 而不是 -1, 所以这里跳过了这个位置.
    
        # 自底向上填充 dp 数组
        # 注意 i 对应 m (外层), j 对应 n (内层)
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                # 为什么-1: 因为 指针 i 对应字符串 s1[i-1] 的字符
                if word1[i - 1] == word2[j - 1]:
                    # 对应位置字符相同，编辑操作数不变, 前移两个指针
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    # 对应字符不同, min 选择
                    # 三种操作, 编辑操作数都要+1
                    dp[i][j] = min(
                        [
                            dp[i][j - 1] + 1,  # 插入或删除
                            dp[i - 1][j] + 1,  # 插入或删除
                            dp[i - 1][j - 1] + 1,  # 替换
                        ]
                    )
        return dp[-1][-1]
```

> 解此类题目最好手画一遍 dp 数组的计算过程.

#### [115. 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/) [hard]

> 给定一个字符串 `s` 和一个字符串 `t` ，计算在 `s` 的子序列中 `t` 出现的个数。
>
> 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
>
> 题目数据保证答案符合 32 位带符号整数范围。
>
> 示例 1：
>
> ```
>输入：s = "rabbbit", t = "rabbit"
> 输出：3
> 解释：如下所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。(上箭头符号 ^ 表示选取的字母)
> rabbbit
> ^^^^ ^^
> rabbbit
> ^^ ^^^^
> rabbbit
> ^^^ ^^^
> ```

##### 分析

1. **确定 dp 数组的定义**: `dp` 数组定义: `dp[i][j]`是字符串`s[0,i)`中出现子序列`t[0,j)`的次数. 因此`dp`数组是一个 `(n+1)*(m+1)`的二维数组.

2. **确定初始化方式**: `dp`数组默认初始化为全0, 但是当`t[0,j]`为一个空串时(即`j==0`时), 此时出现的次数固定为1, 即`dp[i][0] = 1`; 此外, 当`s`是一个空串时, 除非`t`也是一个空串, 否则此时次数为0, 不过这种情况已经包含在默认初始化中了.

3. **确定状态转移过程:** 如果已知 `dp[i][j]` 前面的值, 如何推导出 `dp[i][j]`, 这就要看两个指针指向的字符`s[i-1]`和`t[j-1]`的关系:

   + 如果 `s[i-1] == t[j-1]`, 此时两个子串的末尾字符相同, 此时有两种选择:

     + 一种是选择用当前指向的 `s[i-1]` "匹配掉" `t[j-1]`, 此时问题规模缩小, 两个指针前移, 继续考察剩余的字符, 此时, `dp[i][j] = dp[i-1][j-1]` ;
     + 一种是暂时不 "匹配掉" 这个 `t[j-1]`, 舍弃掉这个 `s[i-1]`, 前移`i`指针, 考察`s`剩余的字符, 此时问题规模没有缩小, `dp[i][j] = dp[i-1][j]`

     上述两种情况都要考虑到, 本题求解的是所有可能性的总数, 故 `dp[i][j] = dp[i-1][j-1] + dp[i-1][j]` ;

   + 如果 `s[i-1] != t[j-1]`, 此时两个子串的末尾字符不相同, 等同于上一种情况中的 "不匹配"分支, 此时只移动`i`指针, 不能移动`j`指针(因为不能缩减问题规模). 因此此时 `dp[i][j] = dp[i-1][j]`

按照上述定义分析, 遍历结束时, 直接返回`dp[n][m]`即为本题答案.

​

```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]
        for i in range(len(s)):
           # j 等于 0, 表示目标 t 是一个空串, 因此此时次数为 1
            dp[i][0] = 1
        for j in range(1, len(t)):
           # i 为 0, 表示搜索空间 s 是一个空串,除非t也是空串, 否则为 0
            dp[0][j] = 0
        for i in range(1, len(s) + 1):
            for j in range(1, len(t) + 1):
                if s[i - 1] == t[j - 1]:
                    #  末尾字符相同，于是 s 有两种选择：
                    #  1. 用s[s.length-1]去匹配掉t[t.length-1]，问题规模缩小：
                    #   继续考察babgba和ba
                    #  2. 不这么做，但t[t.length-1]仍需要被匹配，则在babgba中继续挑，
                    #   考察babgba和bag
                    #  是否用它去匹配，是两种不同的挑选方式，各自做下去所产生的方式数，
                    #  相加，是该大问题的解。
                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]
                else:
                    # s[i]不匹配t[j]，唯有拿s[i]之前的子串去匹配
                    dp[i][j] = dp[i - 1][j]
        return dp[-1][-1]
```

#### [392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)

> 难度简单791
>
> 给定字符串 `s` 和 `t` ，判断 `s` 是否为 `t` 的子序列。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，`"ace"`是`"abcde"`的一个子序列，而`"aec"`不是）。
>
> **进阶：**
>
> *如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？*
>
> **示例**:
>
> ```
> 输入：s = "abc", t = "ahbgdc"
> 输出：true
> ```

##### 分析(双指针-贪心解法)

本题最适合用 **双指针** 的方式求解:

用两个指针`i`和`j`分别指向字符串`s`和`t`的开始字符, **每次贪心地匹配, 如果两个指针指向字符相同, 则两个指针同时右移**; **否则, 只右移`j`指针, `i`不变, 尝试和`t`的下一个字符匹配**.  当其中一个指针移动越界时, 查看`i`指针, 如果`i`指针越界, 则说明`s`全部匹配了, 此时说明`s`是`t`的子序列; 否则说明`s`不是`t`的子序列.

```python
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        n, m = len(s), len(t)
        i = j = 0
        while i<n and j<m:
            if s[i] == t[j]:
                i += 1
                j += 1
            else:
                j += 1
        
        if i == n:
            return True
        else:
            return False
```

 不过本题也可以强行用动态规划求解, 题解见: <https://leetcode.cn/problems/is-subsequence/solution/pan-duan-zi-xu-lie-by-leetcode-solution/>

[对后续挑战的一些思考--如何快速判断大量字符串 - 判断子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/is-subsequence/solution/dui-hou-xu-tiao-zhan-de-yi-xie-si-kao-ru-he-kuai-s/)

## 单序列双指针

**单序列 双指针**情况:

+ `dp`数组 `dp[i][j]` 的定义一般为 `seq[i,j]的最xx的子序列的xx`, 例如 *以`s[i]`开始,以`s[j]`结尾的子串`s[i,j]`的最长回文子序列的长度*.

+ `dp`数组的长度一般为 $n * n$

+ 单序列的双指针, 先确定递推关系, 然后画出`dp`数组,确定初始化, 根据要计算的空格**确定迭代方式**

+ 例子: [#516](##516) 最长回文子序列

#### [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

> 给定一个字符串 `s` ，找到其中最长的**回文子序列**(不需要连续)，并返回该序列的长度。可以假设 `s` 的最大长度为 1000 。
>
> **示例 1:**
>
>  ```
>  输入: "bbbab"
>  输出: 4
>  一个可能的最长回文子序列为 "bbbb"。
>  ```

##### 分析

1. 首先, **确定 `dp` 数组的定义**: 这是一个单序列的双指针问题, 根据解题模板, 定义 `dp`数组 `dp[i][j]` 为 `以s[i]开始,以s[j]结尾的子串s[i,j]的最长回文子序列的长度` . 因此, `dp`数组长度为 $n\times n$.

   > 这里不用担心 `n*n` 会数组越界, 下面的迭代方式使得不会出现数组越界的情况

2. 然后, **确定 `dp` 数组的初始化方式**, 我们画出 二维`dp`数组, 就如下图所示. 这里注意坐标的方向和笛卡尔坐标系不同.

   + 如果 $i=j$ , 则此时 `dp`数组 $dp[i][j]$ 表示的子串$s[i,i]$只有一个字符, **单个字符本身就是一个回文**, 因此, 当 $i=j$ 时, 应该初始化为 1. 即**二维数组对角线上的元素为 1**.
   + 另外, 根据定义, **`i` 小于 `j` 的时候无意义, 也就说没有对应的回文, 此时回文长度为 0**, 因此又将所有的 $i<j$ 的单元格初始化为 0. 也就说除去对角线的**下三角矩阵初始化为 0**.
   + 此时, 注意到除去对角线的**上三角矩阵**在一开始没有值, 因为这里的值需要在计算中确定. 这里为了让程序能够执行也初始化为 0, 但是这里的 0 不是表示回文长度为 0, 是表示还未初始化.

   综上, 我们画出下图的初始化情况, 灰色表示没有合理的值.

   <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603150431.svg" alt="动态规划-二维数组 (1)" style="zoom:50%;" />

3. 然后, 再确定 状态转移的过程: **由于回文是从中间到两端的扩展, 因此我们定义两个指针也是从对称中间向两端扩展**. 因此, 问题也就成了, 如果已知 $dp[i+1][j-1]$, 如何计算得到 $dp[i][j]$ ? 这就要看 `s[i]` 和 `s[j]` 的情况.

   + 如果 $s[i] = s[j]$ : 此时构成了新的回文, **当前的回文长度等于去掉两个字符后的最大回文长度 + 2** (因为有两个字符). 即:

     ```python
     if s[i] == s[j]:
         dp[i][j] = dp[i+1][j-1] + 2
     ```

   + 如果 $s[i] \neq s[j]$ : 此时对应位置字符不相等, **当前的回文长度等于至少去掉其中一个字符后的最大回文长度**( $dp[i+1][j]$ 或者 $dp[i][j-1]$ ), 即:

     ```python
     if s[i] != s[j]:
         dp[i][j] = max(dp[i+1][j], dp[i][j-1])
     ```

     上述两种情况合在一起, 就得到了完整的状态转移过程:

     $$
     dp[i][j] = \
     \begin{cases}
     \begin{align}
     0,&\quad i > j; \\
     1,&\quad i = j; \\
     dp[i+1][j-1]+2,&\quad i<j \land s[i]=s[j]; \\
     max(dp[i+1][j], dp[i][j-1]),&\quad i<j \land s[i] \neq s[j].
     \end{align}
     \end{cases}
     $$

4. 最后, 还需要确定 迭代的方向:

   本题中, 迭代的方向比较难确定. 先看我们的状态转移过程, 要确定 $dp[i][j]$ , 需要用到三个位置: $dp[i+1][j-1]$, $dp[i+1][j]$, $dp[i][j-1]$.  也就是需要已知 **左边, 左下角, 下面** 三个位置. 如下图所示:

   <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603154139.png" alt="image-20210603154139520" style="zoom: 45%;" />

   再看我们需要填充的位置, 实际就是上图的灰色区域, 其他区域已经在初始化中完成填充.

   要完成灰色区域的填充, 且满足上述条件, 实际只有两种可行的迭代方向,

   一种是 **斜着迭代**, 如图:

   <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603154943.svg" alt="动态规划-二维数组 (2)" style="zoom:60%;" />

   代码实现为:

   ```python
   for i in range(1,4):
       # 斜着遍历必须借助 第三个"指针"
       k=i
       for j in range(4-i):
           # do something
           print((j, k))
           k+=1
   ```

   另外一种是 **$i$ 反向, $j$ 正向 迭代**, 如图:

   <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603160311.svg" alt="动态规划-二维数组 (3)" style="zoom:60%;" />

​  代码实现为:

```python
for i in range(len(s) - 2, -1, -1):
    for j in range(i + 1, len(s)):
        # do something
        print((i, j))
```

​ 以上两种都可以, 但显然 **第二种实现更简单**, 这里采用第二种.

最终, 代码实现如下:

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        # 初始化 dp 数组:
        dp = [[0] * len(s) for _ in range(len(s))]
        # 将对角线初始化为 1
        for i in range(len(s)):
            dp[i][i] = 1
        # i 反向, j 正向 迭代:
        # 这里 len(s)-2 是因为计算区域是一个去掉对角线的上三角区域 
        for i in range(len(s) - 2, -1, -1):
            for j in range(i + 1, len(s)):
                if s[i] == s[j]:
                    # 字符相等, 回文长度扩展
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        # dp[0][len(s)-1] 就是整个s上的最大回文子序列长度
        return dp[0][len(s) - 1]
```

> 遇到 `dp` 数组为 2 维的情况, 最好 **画出** `dp` 数组分析.

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

> 给你一个字符串 `s`，找到 `s` 中最长的回文**子串** (要求连续)。
>
> 示例 1：
>
> ```
> 输入：s = "babad"
> 输出："bab"
> 解释："aba" 同样是符合题意的答案。
> ```

##### 分析

本题和 [#516](##516) 很像, 但是本题要求计算的是 回文子串. 注意 `子串` 和 `子序列` 不同, 可以视为子串是一个特殊的子序列, 其要求序列中的字符在原序列中也是**连续**的. 此外这里还要求**输出最后的最长回文子串**, 因此还需要记录下最长的子串.

1. **`dp`数组定义**: 类似 [#516](##516), 但是为了能够输出最终的最长回文子串, 我们需要确定子串的起始位置, 因此我们如此定义 `dp` 数组: `dp[i][j]` 表示 `以s[i]开始,以s[j]结尾的子串s[i:j] 是否是 一个最长回文子串`. 因此 `dp`数组是一个**二维布尔数组**!

   > **注意: ** 不要盲目模仿 *516 最长回文子序列* 将`dp[i][j]` 定义为 `以s[i]开始,以s[j]结尾的子串s[i,j]的最长回文子串的长度`. 因此这样即使最后计算得到了`dp`数组, 也**不好判断具体的回文子串具体是从哪里开始从哪里结束的**.

2. **确定初始化**: 类似 [#516](##516). 我们同样得到下图所示的初始化情况:

   <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603150431.svg" alt="动态规划-二维数组 (1)" style="zoom:60%;" />

   这里 `1` 表示 `True`, `0` 表示 `False`. 和**#516**一样, 对角线上的元素表示自己就是一个回文, 当 `i<j` 时, 为没有回文, 因为全部为 False . **灰色位置表示没有合理的值**, 需要计算.

3. **确定状态转移过程**: 和[#516](##516)类似, 由于回文是从中间到两端的扩展, 因此我们定义两个指针也是**从对称中间向两端扩展**. 因为, 问题也就成了, 如果已知 $dp[i+1][j-1]$, 如何计算得到 $dp[i][j]$ ? 这就要看 `s[i]` 和 `s[j]` 的情况.

   + 如果 $s[i] = s[j]$ : 说明`s[i,j]` **可能是**一个回文子串. 这时要看 $dp[i+1][j-1]$ 是不是为`True`, 也就是看 `s[i+1,j-1]`是不是一个回文子串, **只有当 $dp[i+1][j-1] = True$ 而且当前指针位置两个字符相等时, 才能构成一个连续子串**.

     此外, 这里还有一种特殊情况, 如果子串 `s[i,j]` 的长度 `小于等于3`, 也就是 $j+1-i\leq3$ 时, 则只要两个指针位置的字符相等, 则**必定为回文子串**, 不用看 $dp[i+1][j-1]$的值. 可以注意, **这里实际覆盖了我们初始化中对对角线的初始化.**

     > **注意**: 这里和 [#516](##516) 有很大不同.

   + 如果 $s[i] \neq s[j]$: 则说明 `s[i,j]` **一定不是** 回文子串, 因此, $dp[i][j]$ 一定为 `False`. 注意到, 由于我们初始化的时候默认初始化为了 `False`, 因此这种情况在迭代中实际什么也不需要做.

   综上, 递归公式的形式化如下:

   $$
   dp[i][j] = \
   \begin{cases}
   \begin{align}
   False,&\quad i > j; \\
   True,&\quad i<j \land s[i]=s[j] \land j+1-i\leq3; \\
   True,&\quad i<j \land s[i]=s[j] \land dp[i+1][j-1]; \\
   False,&\quad i<j \land s[i] \neq s[j].
   \end{align}
   \end{cases}
   $$

4. **确定迭代方向**: 由于要填充的位置和和[#516](##516)一样, 这里可以同样使用 **$i$ 反向, $j$ 正向 迭代**, 如图:

   > 和 [#516](##516) 三处限制不同, 这里的限制只有 **左下角** 必须提前计算过. 即,  $dp[i][j]$ 只依赖 $dp[i+1][j-1]$. 因此本例的迭代方向有很多种可能.

   ![动态规划-二维数组 (3)](https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20210603160311.svg)

   > **注意**: 如果不对对角线初始化为True, 则在迭代时也要填充对角线的位置.

综上, 实现如下:

这里要注意为了保存住最长的回文子串, 每次 `dp[i][j]` 为 True 时, 都要判断一下是否为最长的回文子串.

```python
class Solution:
    def longestPalindromeSubseq(self, s: str) -> str:
        # 初始化 dp 数组, 先全部初始化为False:
        dp = [[False] * len(s) for _ in range(len(s))]
        # 将对角线初始化为 True
        # 这里也可以不初始化为True, 但是必须在迭代时计算.
        for i in range(len(s)):
            dp[i][i] = True
        # 记录最长的回文子串
        max_res = s[0]
        max_len = 1
        # 我们选择 i 反向, j 正向 迭代:
        for i in range(len(s) - 2, -1, -1):
            for j in range(i + 1, len(s)):
                if s[i] == s[j] and (dp[i + 1][j - 1] or j + 1 - i <= 3):
                    # 字符相等, 而且构成了回文子串(连续)
                    dp[i][j] = True
                    if j + 1 - i > max_len:
                        max_len = j + 1 - i
                        max_res = s[i : j + 1]
                # 字符不相等, 保持为 False , 不做修改
        return max_res
```

#### [647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)

> 难度中等1075
>
> 给你一个字符串 `s` ，请你统计并返回这个字符串中 **回文子串** 的 **数目**。
>
> **回文字符串** 是正着读和倒过来读一样的字符串。
>
> **子字符串** 是字符串中的由**连续字符**组成的一个序列。
>
> 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。
>
> **示例:**
>
> ```
> 输入：s = "aaa"
> 输出：6
> 解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
> ```

##### 分析

本题是上述题目 *5 最长回文子串*  的变体, 在 *5 最长回文子串* 中我们记录了最长的回文子串的字符串形式, 而这里只需要对上一题的解答稍作修改就可以. 这里我们不再记录 最长回文的字符串, 而是**在判断到时回文的时候 $dp[i][j]=True$ 时, 将记录回文子串数量的变量加一**, 最后返回该变量即可.

```python
class Solution:
    def countSubstrings(self, s: str) -> int:
        n = len(s)
        # n*n 的 Bool 数组
        dp = [ [False] * n for _ in range(n)]
        
        # 对角线上的元素是自身回文的
        for i in range(n):
            dp[i][i] = True
        # 用count记录回文子串的数量
        count = n

        for i in range(len(s)-2, -1, -1):
            for j in range(i+1, n):
                if s[i] == s[j] and (dp[i+1][j-1] or j+1-i<=3):
                    dp[i][j] = True
                    # 是回文子串, 则 count+=1
                    count += 1
        return count
```
