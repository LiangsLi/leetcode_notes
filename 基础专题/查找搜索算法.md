# 查找搜索算法总结

> [[Data Structure & Algorithm] 七大查找算法 - Poll的笔记 - 博客园](https://www.cnblogs.com/maybe2030/p/4715035.html)

查找的**定义**: 在特定数据结构中, 查找取值等于目标值的数据元素.

查找的**分类**:

　　1）静态查找和动态查找；

　　　　注：静态或者动态都是针对查找表而言的。动态表指查找表中有删除和插入操作的表。

　　2）无序查找和有序查找。

　　　　无序查找：被查找数列有序无序均可；

　　　　有序查找：被查找数列必须为有序数列

**查找算法的分类**:

+ 如果是*顺序存储或者线性存储的数据结构*, 例如 数组, 链表:

  + 如果数据结构 **无序**:

    1. `顺序查找`:  从头到尾顺序遍历元素, 如果找到匹配元素则返回. *时间复杂度为 $O(n)$*. 这是最简单的一种搜索算法, 在一些题目中可能是**最朴素的暴力解法**. 例如 *[1. 两数之和](https://leetcode.cn/problems/two-sum/)* ,
    2. `哈希表`: 首先构建哈希表, 根据题目的不同, 哈希表的组成可能是全部元素或者部分元素. *构建哈希表的时间复杂度为 $O(n)$.* 当哈希表构建完成后, 可以直接上上面执行查询, 不考虑冲突的情况下, *哈希查找的时间复杂度为 $O(1)$*. 在有些题目中, 构建哈希表和查询哈希表可以在一个循环中完成, 这样可以将使用顺序查找$O(n^2)$的时间复杂度降低为$O(n)$, 例如  *[1. 两数之和](https://leetcode.cn/problems/two-sum/)*

  + 如果数据结构 **有序**:

    1. `二分查找`: 也称为是折半查找，属于有序查找算法。用给定值`k`先与`中间结点`的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据`k`与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。*期望时间复杂度为 $O(\log{n})$* .

       > *折半查找的前提条件是需要有序表顺序存储*，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用.

       例如: [704. 二分查找](https://leetcode.cn/problems/binary-search/), [1539. 第 k 个缺失的正整数](https://leetcode.cn/problems/kth-missing-positive-number/),  [378. 有序矩阵中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/), [702. 搜索长度未知的有序数组](https://leetcode.cn/problems/search-in-a-sorted-array-of-unknown-size/),  [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

  + 其他情况:

    1. `分块查找`: 分块查找又称`索引顺序查找`，它是顺序查找的一种改进方法。 将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……
