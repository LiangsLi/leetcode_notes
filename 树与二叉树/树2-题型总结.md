# 树题型总结

[toc]

## 深度优先遍历 与 广度优先遍历

#### [144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/) 

前序遍历: `中-左-右`

##### 实现:

递归实现:

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
        if root is None:
            return values
        values.append(root.val)
        values.extend(self.preorderTraversal(root.left))
        values.extend(self.preorderTraversal(root.right))
        return values
```

迭代实现:

```python
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
        if root is None:
            return values
        stack = [root]
        while stack:
            node = stack.pop()
            values.append(node.val)
            # 压栈的时候注意: 先右子树, 再左子树
            if node.right:
                stack.append(node.right)
            if node.left:
                stack.append(node.left)
        return values
```



#### [145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/) 

后序遍历: `左-右-中`, 即 `中-右-左`的取反

##### 实现:

递归实现:

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
       	if root is None:
            return values
        values.extend(self.postorderTraversal(root.left))
        values.extend(self.postorderTraversal(root.right))
        values.append(root.val)
        return values
```

迭代实现(借助`栈`):

```python
class Solution:
    def postorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
       	if root is None:
            return values
        stack = [root]
        while stack:
            node = stack.pop()
            values.append(node.val)
            if node.left:
                stack.append(node.left)
            if node.right:
                stack.append(node.right)
        # 取反
        return values[::-1]
```



#### [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/) 

中序遍历: `左-中-右`

##### 实现:

递归实现:

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
        if not root:
            return values
        values.extend(self.inorderTraversal(root.left))
        values.append(root.val)
        values.extend(self.inorderTraversal(root.right))
        return values
```

迭代实现(借助`栈`和`指针`):

```python
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
        if not root:
            return values
        stack = []
        point = root
        while point or stack:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                point = stack.pop()
                values.append(point.val)
                point = point.right 
        return values
```



#### [508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)

> 难度中等220
>
> 给你一个二叉树的根结点 `root` ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。
>
> 一个结点的 **「子树元素和」** 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。
>
> **示例 1：**
>
> <img src="https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入: root = [5,2,-3]
> 输出: [2,-3,4]
> 解释: 以 5 为根节点的子树的元素和为5+2+-3=4; 以2为根节点的子树的元素和为 2, 以-3为根节点的子树的元素和为 -3.
> ```
>
> **示例 2：**
>
> <img src="https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg" alt="img" style="zoom:50%;" />
>
> ```
> 输入: root = [5,2,-5]
> 输出: [2]
> 解释: 以5为根节点的子树的元素和为2+-5+5=2; 以2为根节点的子树的元素和为2; 以-5为根节点的子树的元素和为-5. 这里2出现次数最多, 故结果为2.
> ```



##### 分析

容易想到**递归遍历**整个树, 自下而上计算每个子树的和, 同时更新一个和的map, 统计每个和出现的次数, 最后返回出现次数最大的keys.

```python
class Solution:
    def findFrequentTreeSum(self, root: Optional[TreeNode]) -> List[int]:
        subSumMap = {}
        
        def helper(root: Optional[TreeNode]) -> int:
            if not root:
                return 0
            leftSum = helper(root.left)
            rightSum = helper(root.right)
            nodeSum = root.val + leftSum + rightSum
            subSumMap[nodeSum] = subSumMap.get(nodeSum,0) + 1
            return nodeSum
        
        helper(root)
        maxCount = max(subSumMap.values())
        return [k for k,v in subSumMap.items() if v==maxCount]
```



#### [589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)

> 难度简单346
>
> 给定一个 n 叉树的根节点  `root` ，返回 *其节点值的 **前序遍历*** 。
>
> n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。

##### 分析:

显然本题用递归实现比较简单:

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""
class Solution:
    def preorder(self, root: 'Node') -> List[int]:
        values = []
        if not root:
            return values
        values.append(root.val)
        for child in root.children:
            values.extend(self.preorder(child))
        return values
```



#### [250. 统计同值子树](https://leetcode.cn/problems/count-univalue-subtrees/)

> 难度中等113
>
> 给定一个二叉树，统计该二叉树数值相同的子树个数。
>
> *同值子树是指该子树的所有节点都拥有相同的数值。*
>
> **补充: 不考虑空节点!**

**示例：**

```
输入: root = [5,1,5,5,5,null,5]

              5
             / \
            1   5
           / \   \
          5   5   5

输出: 4
解释: 三个叶子节点, 右侧子树 5 null 5
```

##### 分析

递归遍历判断每个子树是否是 同值子树

```python
class Solution:
    def countUnivalSubtrees(self, root: Optional[TreeNode]) -> int:
        # 注意这里不能使用函数内局部变量, 因为闭包内需要修改这个值
        self.count = 0

        def dfs(root: Optional[TreeNode]) -> bool:
            if not root.left and not root.right:
                # 叶子节点
                self.count += 1
                return True
            isUnival = True
            if root.left:
                # 注意这里不能先判断 isUnival, 否则可能短路计算, 导致不能完整遍历整个树
                isUnival = dfs(root.left) and isUnival and root.left.val == root.val
            if root.right:
                # 注意这里不能先判断 isUnival, 否则可能短路计算, 导致不能完整遍历整个树
                isUnival = dfs(root.right) and isUnival and root.right.val == root.val
            if isUnival:
                self.count += 1
                return True
            else:
                return False

        if not root:
            return 0
        dfs(root)
        return self.count
```



#### [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

> 难度中等1577
>
> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
>
> **示例**
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[3],[9,20],[15,7]]
> ```

##### 分析

层次遍历需要借助`队列`实现, **Python中用List模拟. 这里需要使用两个队列, 因为循环中无法修改List**.

注意本题要求每一层的节点值嵌套在一个List中

```python
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        if not root:
            return []
        nodes_queues = [root]
        result = []
        while nodes_queues:
            next_level = []
            result_level = []
            for node in nodes_queues:
                if node:
                    result_level.append(node.val)
                    if node.left:
                        next_level.append(node.left)
                    if node.right:
                        next_level.append(node.right)
            result.append(result_level)
            nodes_queues = next_level
            
        return result
```



#### [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

> 难度中等658
>
> 给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
>
> **示例:**
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[15,7],[9,20],[3]]
> ```

##### 分析

直接对 *102 二叉树的层序遍历* 的结果翻转一下就可以了

```python
class Solution:
    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:
        return self.levelOrder(root)[::-1]
```

#### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

> 难度中等812
>
> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
>
> **示例: **
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230220005632.png" alt="image-20230220005632932" style="zoom:33%;" />
>
> ```
> 输入: [1,2,3,4]
> 输出: [1,3,4]
> ```

 ##### 分析

层序遍历每层的时候, 只保存最后一个节点值即可: 

```python
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        nodes_q = [root]
        result = []

        while nodes_q:
            # 每层只保存最后一个节点值
            result.append(nodes_q[-1].val)
            next_level = []
            for node in nodes_q:
                if node:
                    if node.left is not None:
                        next_level.append(node.left)
                    if node.right is not None:
                        next_level.append(node.right)
            nodes_q = next_level
        
        return result
```

#### [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

> 难度简单391
>
> 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。
>
> **示例 **
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[3.00000,14.50000,11.00000]
> 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。
> 因此返回 [3, 14.5, 11] 
> ```

##### 分析:

在层序遍历的时候计算每一层的平均值即可

```python
class Solution:
    def averageOfLevels(self, root: Optional[TreeNode]) -> List[float]:
        if not root:
            return []
        
        nodes_q = [root]
        result = []

        while nodes_q:
            next_level = []
            sum_level = 0
            for node in nodes_q:
                if node:
                    sum_level += node.val
                    if node.left:
                        next_level.append(node.left)
                    if node.right:
                        next_level.append(node.right)
            result.append(sum_level / len(nodes_q))
            nodes_q = next_level
        
        return result
```

#### [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

> 难度中等341
>
> 给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
> 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。

##### 分析

和二叉树层序遍历基本一致, 唯一差别就是现在不是只有左右子树了, 而是有一个子节点列表`children`(可能为None), 需要从这个子节点列表中顺序取出节点, 放入下一层的队列中

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        # children 是 Node 对象组成的列表，也可能为 None
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return []
        
        nodes_q = [root]
        result = []

        while nodes_q:
            next_level = []
            val_level = []
            for node in nodes_q:
                if node:
                    val_level.append(node.val)
                    # 按个取出子节点, 放入下一层的队列中
                    if node.children:
                        for child in node.children:
                            if child:
                                next_level.append(child)
            
            result.append(val_level)
            nodes_q = next_level
        
        return result
```

#### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

> 难度中等298
>
> 给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

##### 分析

层次遍历时, 保存每一层的最大值即可

```python
class Solution:
    def largestValues(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        nodes_q = [root]
        result = []

        while nodes_q:
            next_level = []
            max_level = nodes_q[0].val
            for node in nodes_q:
                if node:
                    max_level = max(node.val, max_level)
                    if node.left:
                        next_level.append(node.left)
                    if node.right:
                        next_level.append(node.right)
            nodes_q = next_level
            result.append(max_level)
        return result
```

#### [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

> 难度中等948
>
> 给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
> ```
> struct Node {
>   int val;
>   Node *left;
>   Node *right;
>   Node *next;
> }
> ```
>
> 填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。
>
> 初始状态下，所有 next 指针都被设置为 `NULL`。
>
> **示例:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230220143917.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,2,3,4,5,6,7]
> 输出：[1,#,2,3,#,4,5,6,7,#]
> 解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
> ```

##### 分析

层序遍历时, 可以依次得到每一层的所有节点, 将每一层的各个节点的`next`指针指向从左到右顺序的下一个节点, 最右侧节点指向`None`即可

```python
class Solution:
    def connect(self, root: 'Optional[Node]') -> 'Optional[Node]':
        if not root:
            return root
        nodes_q = [root]
        while nodes_q:
            next_level = []
            count = len(nodes_q)
            for i in range(count):
                if i == count-1:
                    nodes_q[i].next = None
                else:
                    nodes_q[i].next = nodes_q[i+1]
                node = nodes_q[i]
                if node:
                    if node.left:
                        next_level.append(node.left)
                    if node.right:
                        next_level.append(node.right)
            nodes_q = next_level
        return root
```

#### [103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

难度中等752

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

 

**示例 1：**

![img](https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230323024724.jpeg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[20,9],[15,7]]
```

> [面试题32 - III. 从上到下打印二叉树 III（层序遍历 BFS / 双端队列，清晰图解） - 从上到下打印二叉树 III - 力扣（LeetCode）](https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/solution/mian-shi-ti-32-iii-cong-shang-dao-xia-da-yin-er--3/)

## 特殊遍历



#### [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

> 难度简单1504
>
> 给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
>
> **示例: **
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230220150621.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [4,2,7,1,3,6,9]
> 输出：[4,7,2,9,6,3,1]
> ```

##### 分析

要翻转一个二叉树, 只需要*将每个节点的左右子树都交换一下*就可以了.

###### 递归法(前序/后序)

这里最直观的解法就是使用 前序遍历的递归版本, *每遍历到一个节点, 就先交换左右节点, 然后沿着左右子树继续递归遍历*:

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        # 交换左右子树
        root.left, root.right = root.right, root.left
        # 继续递归遍历
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

注意这里的交换操作可以在左右子树的递归调用前, 也可以在两个递归调用后, 但是**不能在两个递归调用中间!**(因此这样会交换两次) 

也就是说, 可以使用`前序遍历`或者`后序遍历`的递归实现, 但是不能使用中序遍历!

###### 迭代法(前序/后序/层次遍历)

同样也可以使用迭代版本的前序和后序遍历实现翻转:

*前序遍历迭代实现*:

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        stack = [root]
        while stack:
            node = stack.pop()
            if node:
                # 交换左右子树
                node.left, node.right = node.right, node.left
                stack.append(node.right)
                stack.append(node.left)
        
        return root
```

后序遍历的实现和前序类似, 不再赘述.

同样地, 我们也可以使用`层次遍历`的迭代版本实现翻转:

```python
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None

        nodes_q = [root]
        while nodes_q:
            next_level = []
            for node in nodes_q:
                # 交换左右子树
                node.left, node.right = node.right, node.left
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            nodes_q = next_level
        
        return root
```

对比可以看出, 前序遍历和层次遍历的迭代实现非常相似, 虽然一个使用了栈, 一个使用了队列.



#### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

> 难度简单558
>
> 给定二叉树的根节点 `root` ，返回所有左叶子之和。
>
> 
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230221233949.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入: root = [3,9,20,null,null,15,7] 
> 输出: 24 
> 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
> ```

##### 分析:

一个节点是`左叶子节点`,  当且仅当这个节点是父节点的`左子节点`, 且这个节点是`叶子节点`. 据此, 我们可以在遍历时, 对左子树节点做判断, 如果是则累加和. 注意, 右子树节点肯定不是`左叶子节点`, 但其子节点有可能是.

这里可以使用深度优先遍历, 也可以使用广度优先遍历.

```python
class Solution:
    def sumOfLeftLeaves(self, root: Optional[TreeNode]) -> int:

        def dfs(root: Optional[TreeNode]) -> int:
            if not root:
                return 0
            
            res = 0
            
            if root.left:
                left_node = root.left
                if not left_node.left and not left_node.right:
                    # 满足 左叶子节点 的要求
                    res += left_node.val
                else:
                    # 否则继续在左子树上递归
                    res += dfs(left_node)
            
            if root.right:
                # 继续在右子树上递归
                res += dfs(root.right)
            
            return res
        
        return dfs(root)
```

#### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

> 难度中等437
>
> 给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。
>
> 假设二叉树中至少有一个节点。
>
> **示例 2:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230221235509.jpeg" alt="img" style="zoom: 50%;" />
>
> ```
> 输入: [1,2,3,4,null,5,6,null,null,7]
> 输出: 7
> ```

##### 分析:

本题用**层次遍历**实现比较简单, *逐层遍历节点, 最后一层的最左侧节点就是 树的左下角*.

```python
class Solution:
    def findBottomLeftValue(self, root: Optional[TreeNode]) -> int:
        nodes_q  = [root]
        ans = 0
        while nodes_q:
            next_level = []
            for node in nodes_q:
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            # 让ans等于每一层的最左侧节点值, 遍历结束后, ans就是最后一层的最左侧节点值
            ans = nodes_q[0].val
            nodes_q = next_level
        return ans
```





#### [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)

> 难度困难
>
> 给你二叉树的根结点 `root` ，请你设计算法计算二叉树的 **垂序遍历** 序列。
>
> 对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)` 。树的根结点位于 `(0, 0)` 。
>
> 二叉树的 **垂序遍历** 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。
>
> **如果同行同列上有多个结点，则按结点的值从小到大进行排序。**
>
> 返回二叉树的 **垂序遍历** 序列。
>
> 示例 3：
>
> ![img](https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230314230210.jpeg)
>
> ```
> 输入：root = [1,2,3,4,6,5,7]
> 输出：[[4],[2],[1,5,6],[3],[7]]
> 解释：
> 这个示例实际上与示例 2 完全相同，只是结点 5 和 6 在树中的位置发生了交换。
> 因为 5 和 6 的位置仍然相同，所以答案保持不变，仍然按值从小到大排序。
> ```

##### 分析:

本题已经给出了明确的提示, 即: 

> 对位于 `(row, col)` 的每个结点而言，其左右子结点分别位于 `(row + 1, col - 1)` 和 `(row + 1, col + 1)`

有了这个提示, 就容易想到观察节点最后排序时的坐标规律. 

不难看出, 要实现垂直遍历, 只需先序遍历一遍树, 得到所有节点的值和对应的坐标值`(row,col)`(遍历的时候注意将所有`col`取值相同的节点放入一个数组中); 然后**先按照`col`升序排列所有的数组, 再按照`row`对各个数组内做排序**. 

**注意本题要求, 如果坐标相同时, 还需要比较节点的取值.**  

为了实现将所有`col`取值相同的节点放入一个数组中, 这里使用一个`Dict`, `key`是`col`, `value`是所有`col`取值相同的节点列表.

综上, 实现如下:

```python
class Solution:
    def verticalTraversal(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 按照col的取值保存列表
        col2nodes: Dict[int, List[Tuple[int, int]]] = {} 
        
        def dfs(root: Optional[TreeNode], row: int, col: int):
            if not root:
                return
            if col not in col2nodes:
                col2nodes[col] = []
            col2nodes[col].append((root.val, row))
        	# 先序遍历
            # 基于题目提示更新左右子节点的坐标
            dfs(root.left, row+1, col-1)
            dfs(root.right, row+1, col+1)
        
        dfs(root, 0, 0)
        res = []
        # 先按照col对所有的数组做排序
        for _ , nodePairs in sorted(col2nodes.items(), key=lambda i:i[0]):
        	# 然后对每个数组再做一次内部排序, 排序的时候先按照row升序, 再按照val升序
            res.append([np[0] for np in sorted(nodePairs, key=lambda p: (p[1], p[0]))])
        return res
```

#### [314. 二叉树的垂直遍历](https://leetcode.cn/problems/binary-tree-vertical-order-traversal/)

> 难度中等206
>
> 给你一个二叉树的根结点，返回其结点按 **垂直方向**（从上到下，逐列）遍历的结果。
>
> 如果两个结点在同一行和列，那么顺序则为 **从左到右**。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230314225142.jpeg" alt="img" style="zoom: 67%;" />
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：[[9],[3,15],[20],[7]]
> ```

###### 分析:

本题和*上一题 [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/)*  几乎一模一样, 因此上一题的提示和解法在这里依然有效. 

唯一的区别是: 在 [987. 二叉树的垂序遍历](https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/) 中, 要求坐标相同的节点按照节点的取值升序排列, 而**本题要求坐标相同的节点按照从左到右排列**. 

为此, 首先**确保遍历的时候先左后右**, 然后在数组内排序时改为只需要比较`row`取值即可.

具体的实现如下:

```python
class Solution:
    def verticalOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        # 按照col的取值保存列表
        col2nodes: Dict[int, List[Tuple[int, int]]] = {} 
        
        def dfs(root: Optional[TreeNode], row: int, col: int):
            if not root:
                return
            if col not in col2nodes:
                col2nodes[col] = []
            col2nodes[col].append((root.val, row))
        	# 先序遍历
            # 基于题目提示更新左右子节点的坐标
            # 这里一定是 先左后右 !!!
            dfs(root.left, row+1, col-1)
            dfs(root.right, row+1, col+1)
        
        dfs(root, 0, 0)
        res = []
        # 先按照col对所有的数组做排序
        for _ , nodePairs in sorted(col2nodes.items(), key=lambda i:i[0]):
        	# 然后对每个数组再做一次内部排序, 排序的时候先按照row升序即可. 
            # 如果坐标相同, 则会按照遍历的顺序排列, 即 先左后右
            res.append([np[0] for np in sorted(nodePairs, key=lambda p: p[1])
        return res
```

## 最近公共祖先(LCA)

> [最近公共祖先 - OI Wiki](https://oi-wiki.org/graph/lca/)

+ 普通二叉树的LCA解法:
  1. **递归**回溯查找, 此时需要注意递归的返回值, **此时时间复杂度为 $O(N)$, 空间复杂度为 $O(N)$**. 具体分析见 *问题 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/) 的解法一* ;
  2. 首先建立根节点到所有节点的**反向映射表**(通过遍历构建即可)(**时间复杂度为 $O(N)$, 空间复杂度为 $O(N)$**), 通过这个哈希表, 我们得到**从目标节点到根节点的唯一反向路径**, 因此此时问题就退化为了 *问题 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)* , *等同于在两个链表上找相交点*, 此时存在两种解决思路:
     1. 先沿着第一个目标节点`a`, 反向遍历, 直到父节点为`null`为止, 同时将每个遍历到的父节点保存在一个**哈希表**`parents_a`中; 然后再沿着第二个目标节点`b`反向遍历, 如果`b`的父节点出现在`parents_a`中, 则这个节点就是最近公共祖先节点. **此时时间复杂度为 $O(m+n)$, 空间复杂度为 $O(m)$**. 具体分析见 *问题 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 和 问题 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)*. 这种方式也可以解决类似 *问题 [599. 两个列表的最小索引总和](https://leetcode.cn/problems/minimum-index-sum-of-two-lists/)*
     2. 利用双指针, 假设目标节点`a`的反向路径长度为 `A+C`, 目标节点`b`的反向路径长度为`B+C`, 其中`C`为两个反向路径的公共部分, `A`,`B`为两个反向路径的不同部分. 则令指针`p1`沿着 `A+C+B+C` 遍历, 令指针`p2`沿着 `B+C+A+C` 遍历, 这两个遍历长度相同, 因此可以同时在一个循环中完成. 如果两个路径有相交部分, 则一定会在遍历时同时遇到(此时`p1==p2`); 否则, 则两个指针一定会同时遇到`null`, 此时还是`p1==p2`, 因此`p1==p2`就是循环的退出条件. 退出循环后直接返回`p1`即可; **此时时间复杂度为 $O(m+n)$, 空间复杂度为 $O(1)$**. 具体分析见 *问题 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 和 问题 [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)*

+ 二叉搜索树的LCA解法: 二叉搜索树依然可以通过上述的普通二叉树解法求解. 不过, 效率最好的方式是利用二叉搜索树的优势, 即搜索方便, 首先搜索两个目标节点, 并保存路径, 由此可以得到两个目标节点的正向路径. 此时问题就变为了*求两个路径的分叉点* (可以视为是 *问题 [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 的相反问题*), 此时齐头遍历, 遇到不相等的节点退出循环即可, 具体见 *问题 [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)*



#### [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

> 难度简单2019
>
> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。

##### 解法一: 借助哈希表

先沿着第一个目标节点`a`, 反向遍历, 直到父节点为`null`为止, 同时将每个遍历到的父节点保存在一个**哈希表**`parents_a`中; 然后再沿着第二个目标节点`b`反向遍历, 如果`b`的父节点出现在`parents_a`中, 则这个节点就是最近公共祖先节点. **此时时间复杂度为 $O(m+n)$, 空间复杂度为 $O(m)$**. 

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        p1 = headA
        p2 = headB

        parents_a = {}
        while p1 is not None:
            parents_a[p1] = True
            p1 = p1.next
        while p2 is not None:
            if parents_a.get(p2, False):
                return p2
            p2 = p2.next
        return None
```

##### 解法二: 双指针

利用双指针, 假设目标节点`a`的反向路径长度为 `A+C`, 目标节点`b`的反向路径长度为`B+C`, 其中`C`为两个反向路径的公共部分, `A`,`B`为两个反向路径的不同部分. 则令指针`p1`沿着 `A+C+B+C` 遍历, 令指针`p2`沿着 `B+C+A+C` 遍历, 这两个遍历长度相同, 因此可以同时在一个循环中完成. 如果两个路径有相交部分, 则一定会在遍历时同时遇到(此时`p1==p2`); 否则, 则两个指针一定会同时遇到`null`, 此时还是`p1==p2`, 因此`p1==p2`就是循环的退出条件. 退出循环后直接返回`p1`即可; **此时时间复杂度为 $O(m+n)$, 空间复杂度为 $O(1)$**. 

```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
        p1 = headA
        p2 = headB

        while p1 != p2:
            p1 = p1.next if p1 else headB
            p2 = p2.next if p2 else headA
        return p1
```





#### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

> 难度中等2195
>
> 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
>  
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315170904.png" alt="img" style="zoom:77%;" />
>
> ```
> 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
> 输出：3
> 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
> ```

##### 分析:

###### **解法一: 递归回溯查找**

根据定义, 如果`root`是`p`,`q`的`最近公共祖先`, 则只可能为如下情况之一:

1. `q`和`p`分别位于`root`的左右子树中(**异侧**) ;
2. `q==root`, 且`p`在`root`的左子树或者右子树中;
3. `p==root`, 且`q`在`root`的左子树或者右子树中;

一个比较直观的方式就是**自下而上地遍历**, 而在树结构中自下而上就是`回溯`, 这里我们采用 `后序遍历`.

> `后序遍历` 的过程就是自下而上的`回溯`

递归的详细过程为:

1. 何时终止:

   + 如果 `root`为空, 则直接返回 `null`(也就是`root`本身);
   + 如果`root`非空, 且`p==q==root`, 则说明`root`本身就是最近公共祖先, 直接返回`root`;

   > 上面的两个终止情况都是直接返回`root`即可

2. 处理过程: 在左右子树上递归, 并判断两个子树的返回值(`left`和`right`), 具体有四种情况:

   1. `left`和`right`都为空, 则说明左右子树中都没有找到`q`或者`p`, 此时返回 `null`;
   2. `left`和`right`都不为空, 则说明左右子树中各自都找到了`q`或者`p`(本题要求节点值不重复), 则说明此时`root`就是最近祖先, 此时返回`root`;
   3. `left`为空, `right`不为空, 说明左子树中没有找到`q`或者`p`, 此时右子树有两种情况:
      + 右子树中包含最近祖先(`q`和`p`都在右子树), 就是返回值`right`, 此时直接向上返回右子树的返回值`right`即可;
      + 右子树中包含一个节点(`q`或者`p`), 此时返回值`right`指向找到的目标节点, 此时继续向上返回`right`, 从而使得在上层节点中找到另外一个节点时, 返回最近公共祖先;
   4. `right`为空, `left`不为空, 此时和 *情况3* 类似;

综上, 我们可以写出如下的递归判断过程:

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or root == p or root == q: 
            return root
        
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)
        
        # `left`和`right`都为空, 则说明左右子树中都没有找到`q`或者`p`, 
        #  此时返回 `null`
        if not left and not right: 
            return
        # `left`为空, `right`不为空, 此时返回right
        if not left: 
            return right
        # `right`为空, `left`不为空, 此时返回left
        if not right: 
            return left
        #  `left`和`right`都不为空, 此时`root`就是最近祖先
        return root
```

###### **解法二: 构建父节点映射, 反向遍历**

上述解法一种我们分析实现了基于递归的`回溯`查找. 通过递归查找左右子树, 然后根据左右子树的查找结果向上返回不同的返回值. 递归解法比较简洁, 但是逻辑有些难理解.

此外, 还有另外一种解法:

1. 首先我们构造一个 **子节点到父节点的反向映射**, 此时除了根节点之外, 其他的节点都在这个映射表的`keys`中;
2. 然后, 用待查找的`q`自下而上遍历, 直到遍历到根节点为止, 得到`q`的所有祖父节点数组`q_parents`; 注意, **一个节点本身也是自己的祖父节点**, 因此, `q` 需要先放置到 `q_parents`中
3. 接下来用待查找的`p`自下而上遍历, 每次遍历得到一个祖父节点, 都先判断一下是否在 `q_parents`中, 如果在, 那么该祖父节点就是`最近祖父节点`. 

具体的实现如下: 注意下面的实现中, 我们使用映射`parents_p_map`代替了`q_parents`数组, 因为这样更方便查找.

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root: 
            return root
    
        # 子节点到父节点的反向映射表
        self.child2parent: Dict[int, int] = {}

        def dfs(root: 'TreeNode'):
            if root.left:
                self.child2parent[root.left.val] = root
                dfs(root.left)
            if root.right:
                self.child2parent[root.right.val] = root
                dfs(root.right)
                
        # 递归建立反向映射表
        dfs(root)
        # 反向查找 p 的祖父节点
        parents_p_map: Dict[int, bool] = {}
        while p is not None:
            # 这里首先将 p 放入了 p 的祖父节点数组中.
            # 一个节点本身也是自己的祖父节点
            parents_p_map[p.val] = True
            # 当get返回None时, 说明已经向上回溯到了整个树的根节点
            p = self.child2parent.get(p.val, None)
        # 再反向查找 q 的祖父节点
        while q is not None:
            if parents_p_map.get(q.val, False):
                return q
            q = self.child2parent.get(q.val, None)
        return None
```

由于本题需要返回一个`TreeNode`, 因此这里的`child2parent`的`value`需要保存父节点(而不是父节点的值)

> 解法二逻辑比较简单, 但是代码稍微长一点. 在解决树的最近祖父节点问题时, 解法一和解法二都可以, 复杂度也差不多(解法二略大). **解法二更适合一些本身不是树形组织结构的最近祖父节点问题**, 例如题目 *1257. 最小公共区域* .



#### [1257. 最小公共区域](https://leetcode.cn/problems/smallest-common-region/)

> 难度中等48
>
> 给你一些区域列表 `regions` ，每个列表的第一个区域都包含这个列表内所有其他区域。
>
> 很自然地，如果区域 `X` 包含区域 `Y` ，那么区域 `X` 比区域 `Y` 大。
>
> 给定两个区域 `region1` 和 `region2` ，找到同时包含这两个区域的 **最小** 区域。
>
> 如果区域列表中 `r1` 包含 `r2` 和 `r3` ，那么数据保证 `r2` 不会包含 `r3` 。
>
> 数据同样保证最小公共区域一定存在。
>
>  
>
> **示例 1：**
>
> ```
> 输入：
> regions = [["Earth","North America","South America"],
> ["North America","United States","Canada"],
> ["United States","New York","Boston"],
> ["Canada","Ontario","Quebec"],
> ["South America","Brazil"]],
> region1 = "Quebec",
> region2 = "New York"
> 输出："North America"
> ```

##### 分析

这里的`regions`列表实际给出了每一个父节点和对应的子节点, 如果画出这个列表对应的结构, 应该是一个`N叉树`. 因此本题实际上就是N叉树上的**LCA(最近公共祖父)问题**.

因此本题可以使用 上一题 *[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)* 中的对应解法求解. 如果使用解法一, 首先需要构造一个树, 实在是没必要. 而这里的给出的列表结构非常适合解法二. 因此这里使用**解法二**求解, 即: *首先构造子节点到父节点的映射表, 然后反向遍历两个目标节点, 找到相交的节点.*

代码如下:

```python
class Solution:
    def findSmallestRegion(self, regions: List[List[str]], region1: str, region2: str) -> str:
        # 子节点到父节点的映射
        child2parents = {}
        # 构建映射
        for region in regions:
            for i in range(1, len(region)):
                child2parents[region[i]] = region[0]
        # 回溯region1的祖父节点
        r1_parents_map = {}
        while region1 is not None:
            r1_parents_map[region1] = True
            region1 = child2parents.get(region1, None)
        # 回溯region2的祖父节点
        while region2 is not None:
            if r1_parents_map.get(region2, False):
                return region2
            region2 = child2parents.get(region2, None)
```

#### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

> 难度中等1040
>
> 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
> [百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”
>
> 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315220201.png" alt="img" style="zoom: 80%;" />
>
>  
>
> **示例 1:**
>
> ```
> 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
> 输出: 6 
> 解释: 节点 2 和节点 8 的最近公共祖先是 6。
> ```

##### 分析:

> 本题可以直接套用 *[236. 二叉树的最近公共祖先 ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)*的解法, 但是题目 *[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)* 中是一个普通二叉树, 而这里是一个二叉搜索树, *如果可以利用二叉搜索树的性质, 可以实现更加高效的解法.* 

由于本题需要在BST中查找两个节点`p` , ` q`, 然后给出这两个节点的 LCA(最近公共祖父), 容易想到, **BST可以实现高效的查找**, 任何一个节点只要在BST中, 那么它的路径是可以在一次自上而下的遍历中找到的(也就是**找到路径上的分叉点**). 因此本题的解法如下:

> 树结构中, 从根节点到任意节点的路径是唯一的.

1. 利用BST的性质, 在 $O(n)$ 时间内找到从根节点到`p`的路径`path_p` 和从根节点到`q`的路径 `path_q`;
2. 齐头遍历`path_p` 和 `path_q`:
   + 如果 `path_q[i] == path_p[i]`, 则该节点是一个公共祖先(不一定是最近的祖先), 更新 `ancestor = path_p[i]`; 
   + 如果 `path_q[i] != path_p[i]`, 则说明两个路径已经分叉了,  后面必然不是公共祖先节点了, 此时停止遍历, 返回 `ancestor` 即可;

具体实现如下:

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':

        def findPath(root: 'TreeNode', target: 'TreeNode') -> List['TreeNode']:
            path = []
            node = root
            while node != target:
                path.append(node)
                if target.val > node.val:
                    node = node.right
                else:
                    node = node.left
            path.append(node)
            return path
        
        path_p = findPath(root, p)
        path_q = findPath(root, q)
        ancestor = root
        # zip 在遍历两个不等长的list时, 会自动截断
        for pp,qq in zip(path_p, path_q):
            if pp.val == qq.val:
                ancestor = pp
            else:
                break
        return ancestor
```

**进一步优化:** 观察上述的实现, 我们做了两次路径查找, 然后又做了一次路径遍历. *其实上述的两个节点的路径查找和祖父节点更新可以在一次树遍历中完成*. 整体的流程为:

1. 初始化祖父节点 `ancestor = root`, 然后开始循环, 直到 祖父节点 `ancestor` 为空 为止 ;
2. 如果`p`和`q`的值都 小于 当前 祖父节点 `ancestor`, 则说明两个节点都在祖父节点的左子树上, 则更新 `ancestor = ancestor.left`, 进入下一轮循环;
3. 如果`p`和`q`的值都 大于 当前 祖父节点 `ancestor`, 则说明两个节点都在祖父节点的右子树上, 则更新 `ancestor = ancestor.right`, 进入下一轮循环;
4. 如果不满足情况2和情况3, 则说明两个节点的路径在当前祖父节点开始分岔了, 则说明此时的祖父节点就是**最近祖父节点**. 直接退出循环, 返回 `ancestor` 即可;

具体实现如下:

```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        ancestor = root
        while True:
            if p.val < ancestor.val and q.val < ancestor.val:
                ancestor = ancestor.left
            elif p.val > ancestor.val and q.val > ancestor.val:
                ancestor = ancestor.right
            else:
                break
        return ancestor
```

> 为什么求解普通二叉树的LCA问题时, 不通过这个题目类似的方式, 即先找两目标节点路径, 然后判断路径分叉点的方式解决呢? 这是因为*普通二叉树查找目标节点的路径成本比较高, 而找到反向映射比较简单*; 而*二叉搜索树的优势就是搜索, 也就是找目标节点的路径成本很小*.
>
> 因此 , *对于普通二叉树的LCA问题, 要么递归分解判断; 要么先构建一个反向映射表, 然后反向回溯找公共祖父*; 而*对于二叉搜索树, 可以通过先找路径, 然后找路径的分叉点的方式求解.*

#### [1644. 二叉树的最近公共祖先 II](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii/)

> 难度中等
>
> 给定一棵二叉树的根节点 `root`，返回给定节点 `p` 和 `q` 的最近公共祖先（LCA）节点。如果 `p` 或 `q` 之一 **不存在** 于该二叉树中，返回 `null`。树中的每个节点值都是互不相同的。
>
> 根据[维基百科中对最近公共祖先节点的定义](https://en.wikipedia.org/wiki/Lowest_common_ancestor)：“两个节点 `p` 和 `q` 在二叉树 `T` 中的最近公共祖先节点是 **后代节点** 中既包括 `p` 又包括 `q` 的最深节点（我们允许 **一个节点为自身的一个后代节点** ）”。一个节点 `x` 的 **后代节点** 是节点 `x` 到某一叶节点间的路径中的节点 `y`。



#### [1650. 二叉树的最近公共祖先 III](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iii/)

> 难度中等34
>
> 给定一棵二叉树中的两个节点 `p` 和 `q`，返回它们的最近公共祖先节点（LCA）。
>
> 每个节点都包含其父节点的引用（指针）。`Node` 的定义如下：
>
> ```
> class Node {
>     public int val;
>     public Node left;
>     public Node right;
>     public Node parent;
> }
> ```
>
> 根据[维基百科中对最近公共祖先节点的定义](https://en.wikipedia.org/wiki/Lowest_common_ancestor)：“两个节点 p 和 q 在二叉树 T 中的最近公共祖先节点是后代节点中既包括 p 又包括 q 的最深节点（我们允许**一个节点为自身的一个后代节点**）”。一个节点 x 的后代节点是节点 x 到某一叶节点间的路径中的节点 y。



#### [1676. 二叉树的最近公共祖先 IV](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-iv/)

> 难度中等
>
> 给定一棵二叉树的根节点 `root` 和 `TreeNode` 类对象的数组（列表） `nodes`，返回 `nodes` 中所有节点的最近公共祖先（LCA）。数组（列表）中所有节点都存在于该二叉树中，且二叉树中所有节点的值都是互不相同的。
>
> 我们扩展[二叉树的最近公共祖先节点在维基百科上的定义](https://en.wikipedia.org/wiki/Lowest_common_ancestor)：“对于任意合理的 `i` 值， `n` 个节点 `p1` 、 `p2`、...、 `pn` 在二叉树 `T` 中的最近公共祖先节点是**后代**中包含所有节点 `pi` 的最深节点（我们允许一个节点是其自身的后代）”。一个节点 `x` 的后代节点是节点 `x` 到某一叶节点间的路径中的节点 `y`。

## 求二叉树的属性

#### [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

> 难度简单1508
>
> 给定一个二叉树，找出其最大深度。
>
> 二叉树的**深度**为根节点到最远叶子节点的最长路径上的节点数。
>
> **说明:** 叶子节点是指没有子节点的节点。
>
> **示例：**
> 给定二叉树 `[3,9,20,null,null,15,7]`，
>
> ```
>  3
> / \
> 9  20
>  /  \
> 15   7
> ```
>
> 返回它的最大深度 3 

##### 分析

`层次遍历`时记录一下遍历的层数即可

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        nodes_q = [root]
        level = 0

        while nodes_q:
            next_level = []
            for node in nodes_q:
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            level += 1
            nodes_q = next_level

        return level
```

本题也可以通过**深度优先遍历的递归方式**求解:

要求一个树的高度, 实际就是求出左右子树的各自高度, 然后最大高度加一即可. 递归结束的条件是: 当遇到空节点时, 令其高度为0, 直接返回. 

这样就可以自下而上地得到所有节点作为根节点时的树高:

```python
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left_h = self.maxDepth(root.left)
        right_h = self.maxDepth(root.right)
        return max(left_h, right_h) + 1
```

> **注意**上面的深度优先**递归**实现, 在 *110 平衡二叉树* 和 *543. 二叉树的直径* 中也使用了类似的实现思路!



#### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

> 难度简单930
>
> 给定一个二叉树，找出其最小深度。
>
> 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
> **说明：**叶子节点是指没有子节点的节点。1
>
> **示例: **
>
> ```
> 输入：root = [3,9,20,null,null,15,7]
> 输出：2
> ```

##### 分析

在**层次遍历**每一层时, 记录层数, 同时逐个节点判断是否左右子树皆为`None`, 如果有, 这说明是叶子结点(`leaves`). 当遇到第一个叶子结点时, 退出迭代, 返回此时的层数.

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        nodes_q = [root]
        min_level = 0

        found_leave = False
        while nodes_q:
            next_level = []
            for node in nodes_q:
                if not node.left and not node.right:
                    found_leave = True
                    break
                if node.left:
                    next_level.append(node.left)
                if node.right:
                    next_level.append(node.right)
            min_level += 1
            nodes_q = next_level
            if found_leave:
                break
        
        return min_level
```

和上一题 *104 二叉树的最大深度* 一样, 本题也可以用**深度优先递归实现**, 只不过需要注意返回的条件判断.

注意这里**不能**类比上一题, 直接返回 `min(leftHeight, rightHeight) + 1`, 需要判断左右子树是否存在

```python
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        """
            当 root 节点左右孩子都为空时，返回 1
            当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度
            当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值
        """
        if not root:
            return 0
        leftHeight = self.minDepth(root.left)
        rightHeight = self.minDepth(root.right)

        if root.left and root.right:
            # 两个子节点都不为空, 则返回两个子节点高度的最小值+1
            return min(leftHeight, rightHeight) + 1
        else:
            # 两个子节点至少有一个为空, 则此时应该返回不为空的子节点的高度+1
            # 这里不需要进一步判断哪个子树不为空, 
            # 因为此时 leftHeight 和 rightHeight 肯定至少有一个为零
            # 因此直接返回 leftHeight + rightHeight + 1 即可
            return leftHeight + rightHeight + 1
```



#### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)

> 难度中等547
>
> 给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。
>
> 树的 **最大宽度** 是所有层中最大的 **宽度** 。
>
> 每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。
>
> 题目数据保证答案将会在 **32 位** 带符号整数范围内。
>
> 示例 2：
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230314163739.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,3,2,5,null,null,9,6,null,7]
> 输出：7
> 解释：最大宽度出现在树的第 4 层，宽度为 7 (6,null,null,null,null,null,7) 。
> ```
>
> **示例 3：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230314163752.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,3,2,5]
> 输出：2
> 解释：最大宽度出现在树的第 2 层，宽度为 2 (3,2) 。
> ```

##### 分析

首先想到的使用**层次遍历**, 逐层判断宽度, 由于本题的定义为 "*每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度* ", 因此这里还需要保存空节点. **原始实现**如下:

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        maxWidth = 0
        queue = [root]
        while queue:
            nextLevel = []
            allEmpty = True
            # 记录左右非空节点的索引
            levelLeft = -1
            levelRight = -1
            for i, node in enumerate(queue):
                if node:
                    if levelLeft == -1:
                        levelLeft = i
                    levelRight = i
                    allEmpty = False
                    # 这里子节点有可能为空
                    nextLevel.append(node.left)
                    nextLevel.append(node.right)
                else:
                    # 按照题目要求, 空节点也要放进去
                    nextLevel.append(None)
                    nextLevel.append(None)
            if allEmpty:
                break
            queue = nextLevel
            maxWidth = max(maxWidth, levelRight-levelLeft+1)
        return maxWidth
```

上面的代码提交后发现会在一个长测试用例(有很多空节点)上**超时**. 分析*上述代码将大量时间花在了保存/遍历空节点上*. 为此, 进一步简化逻辑如下:

可以看出, 在层次遍历时, **关键是记录下每一层的最左/最右侧的非空节点的索引**, 然后可以通过这个索引相减得到这一层的宽度. 那么**如何在不保存空节点的时候正确得到这个索引呢?**

画出每层每个节点的索引, 如下图:

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230314172301.png" alt="image-20230314172301698" style="zoom:50%;" />

可以发现如下规律:
$$
\begin{align}
LeftChild_{index} &= Root_{index} * 2 \\
RightChild_{index} &= Root_{index} * 2 + 1
\end{align}
$$
通过上述的索引规律, 我们可以不用再保存大量无用的空节点, 从而进一步优化代码如下:

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        maxWidth = 0
        # 每个节点保存一个索引值
        if not root:
            return 0
        queue = [(root, 0)]
        while queue:
            # 此时最左侧节点就是首个元素, 最右侧节点就是最后一个元素
            maxWidth = max(maxWidth, queue[-1][1]-queue[0][1]+1)
            nextLevel = []
            for node,idx in queue:
                # 此时队列中只保存非空节点
                if node.left:
                    nextLevel.append((node.left, idx*2))
                if node.right:
                    nextLevel.append((node.right, idx*2+1))
            queue = nextLevel
        return maxWidth
```

当然, 本题也可以通过**深度优先遍历(递归)**实现, *不过本题递归实现比较麻烦*. 以前序遍历为例, 递归时首先访问每层的最左侧节点, 我们在外侧维护一个映射表, 记录每层的最左侧节点的索引. 每遍历到一个节点, 都判断当前节点索引和最左侧节点的差值, 以及左右子树递归返回值的最大值. 为此, 递归函数需要增加两个参数`depth 深度` 和 `index 索引`. 代码如下:

```python
class Solution:
    def widthOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        # 保存每一层的最左侧节点的索引值
        leftIndex = {}

        def dfs(node: Optional[TreeNode], depth: int, index: int) -> int:
            if node is None:
                return 0
            if depth not in leftIndex:
                # 每一层最先访问到的节点会是最左边的节点，即每一层编号的最小值
                leftIndex[depth] = index  
            return max(index - leftIndex[depth] + 1,
                       dfs(node.left, depth + 1, index * 2),
                       dfs(node.right, depth + 1, index * 2 + 1))
        
        return dfs(root, 0, 0)
```

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

> 难度简单1277
>
> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的**直径长度是任意两个结点路径长度中的最大值**。这条路径可能穿过也可能不穿过根结点。
>
>  
>
> **示例 :**
> 给定二叉树
>
> ```
>           1
>          / \
>         2   3
>        / \     
>       4   5    
> ```
>
> 返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。



```python
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node:
                return 0
            # 左儿子为根的子树的深度
            L = depth(node.left)
            # 右儿子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L + R + 1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1
```





#### [2458. 移除子树后的二叉树高度](https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/)

难度困难28收藏分享切换为英文接收动态反馈

给你一棵 **二叉树** 的根节点 `root` ，树中有 `n` 个节点。每个节点都可以被分配一个从 `1` 到 `n` 且互不相同的值。另给你一个长度为 `m` 的数组 `queries` 。

你必须在树上执行 `m` 个 **独立** 的查询，其中第 `i` 个查询你需要执行以下操作：

- 从树中 **移除** 以 `queries[i]` 的值作为根节点的子树。题目所用测试用例保证 `queries[i]` **不** 等于根节点的值。

返回一个长度为 `m` 的数组 `answer` ，其中 `answer[i]` 是执行第 `i` 个查询后树的高度。

**注意：**

- 查询之间是独立的，所以在每个查询执行后，树会回到其 **初始** 状态。
- 树的高度是从根到树中某个节点的 **最长简单路径中的边数** 。

## 二叉树路径问题



> *参考:*
>
> + [一篇文章解决所有二叉树路径问题（问题分析+分类模板+题目剖析） - 从叶结点开始的最小字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/smallest-string-starting-from-leaf/solution/yi-pian-wen-zhang-jie-jue-suo-you-er-cha-10sk/)
> + [Leetcode --- 矩阵路径问题（动态规划）-阿里云开发者社区](https://developer.aliyun.com/article/925682)
> + [最短路径算法总结和LeetCode题目实践 / Drrany](https://drrany.github.io/ShortestPathAlgorithm/)
> + [【视频】彻底掌握直径 DP！从二叉树到一般树！（Python/Java/C++/Go） - 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-n9s91/)

### 自顶向下类题目

这里题目的特征是明确要求从**根节点开始, 到叶子节点(或者某个满足条件的节点)为止**. 因此是*自顶向下*的问题. 这类题目可以通过`深度优先遍历`解决.

**这类题型DFS注意点：**

+ 如果是找 **路径和等于给定和`target`的路径**，那么可以**不用**新增一个临时变量`cursum`来判断当前路径和，
  只需要用**给定和`target`减去节点值，最终结束条件判断`target==0`即可**, 这样可以减少一个参数!

+ 是否要`回溯`：二叉树的问题大部分是不需要回溯的，原因为: 二叉树的递归部分 `dfs(root->left)`和 `dfs(root->right)` 已经把可能的路径穷尽了, 因此到**任意叶节点的路径只可能有一条**，绝对不可能出现另外的路径也到这个满足条件的叶节点的;

  > 而对比**二维数组(例如迷宫问题)**的DFS, `for`循环向四个方向查找每次只能朝向一个方向，并没有穷尽路径，因此**某一个满足条件的点可能是有多条路径到该点的**. 并且`visited`数组标记已经走过的路径是会受到另外路径是否访问的影响，这时候必须`回溯.`

+ 找到路径后是否要`return`: 取决于题目是否要求找到叶节点满足条件的路径, 如果必须到叶节点,那么就要return; 但如果是到任意节点都可以，那么必不能return,因为这条路径下面还可能有更深的路径满足条件，还要在此基础上继续递归

+ 是否要`双重递归`：看题目要不要求从根节点开始的，还是从任意节点开始

**DFS模板:**

```cpp
// 一般路径：
vector<vector<int>>res;
void dfs(TreeNode*root,vector<int>path)
{
    if(!root) return;  //根节点为空直接返回
    path.push_back(root->val);  //作出选择
    if(!root->left && !root->right) //如果到叶节点  
    {
        res.push_back(path);
        return;
    }
    dfs(root->left,path);  //继续递归
    dfs(root->right,path);
}

// 满足某个和的路径：
void dfs(TreeNode*root, int sum, vector<int> path)
{
    if (!root)
        return;
    sum -= root->val;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == 0)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, sum, path);
    dfs(root->right, sum, path);
}
```



#### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)

> 难度简单889
>
> 给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例: **
>
> ```
> 输入：root = [1,2,3,null,5]
> 输出：["1->2->5","1->3"]
> ```

##### 分析

本题可以用`深度优先遍历`实现, 这里使用递归版本. 当遍历到非叶子节点时, 将当前节点值写入路径, 并继续递归遍历左右子树; 当遍历到叶子节点时, 将当前节点写入路径,  并将当前路径保存到结果中.

这里实际用的是前序遍历.

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []

        def helper(root: Optional[TreeNode], prefix: str):
            if not root:
                return
            
            prefix += f"{root.val}"
            if not root.left and not root.right:
                res.append(prefix)
            else:
                # 非叶子节点, 后面还有其他节点, 所以要加入 ->
                prefix += "->"
                helper(root.left, prefix)
                helper(root.right, prefix)
        
        helper(root, "")
        return res
```

当然也可以用层序遍历(`广度优先遍历`)实现, 实现思路和深度优先基本一致:

```python
class Solution:
    def binaryTreePaths(self, root: Optional[TreeNode]) -> List[str]:
        res = []
        nodes_q = [(root, "")]
        while nodes_q:
            next_level = []
            for node, prefix in nodes_q:
                prefix += str(node.val)
                if not node.left and not node.right:
                    res.append(prefix)
                else:
                    # 非叶子节点, 后面还有其他节点, 所以要加入 ->
                    prefix += "->"
                    if node.left:
                        next_level.append((node.left, prefix))
                    if node.right:
                        next_level.append((node.right, prefix))
            nodes_q = next_level
        return res
```

#### [988. 从叶结点开始的最小字符串](https://leetcode.cn/problems/smallest-string-starting-from-leaf/)

> 难度中等97
>
> 给定一颗根结点为 `root` 的二叉树，树中的每一个结点都有一个 `[0, 25]` 范围内的值，分别代表字母 `'a'` 到 `'z'`。
>
> 返回 ***按字典序最小** 的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束*。
>
> > 注**：**字符串中任何较短的前缀在 **字典序上** 都是 **较小** 的：
> >
> > - 例如，在字典序上 `"ab"` 比 `"aba"` 要小。叶结点是指没有子结点的结点。 **但是 `xy` 要比 `abc` 大**
>
> 节点的叶节点是没有子节点的节点。
>
> **示例 1：**
>
> **<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222234407.png" alt="img" style="zoom:50%;" />**
>
> ```
> 输入：root = [0,1,2,3,4,3,4]
> 输出："dba"
> ```

##### 分析

暴力解法是利用深度优先遍历, 得到所有从根节点到叶子节点的反向路径字符串, 然后对这些字符串排序, 返回最小的字符串.

该解法如下:

```python
class Solution:
    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:
        def dfs(root: Optional[TreeNode], path: str):
            if not root:
                return ""
            # 将节点值转为char字符(a-z)
            path += res[root.val]
            if not root.left and not root.right:
                # 保存路径的反向字符串
                pathStrs.append(path[::-1])
            if root.left:
                dfs(root.left, path)
            if root.right:
                dfs(root.right, path)
        
        if not root:
            return ""
   		pathStrs = []
        # 构建一个0-25到a-z的映射表
        res = {}
        for i in range(26):
            res[i] = chr(ord('a') + i)
        dfs(root, "")
        # 按照字符串排序
        pathStrs.sort()
        return pathStrs[0]
```

#### [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)

> 难度中等611
>
> 给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。
>
> 每条从根节点到叶节点的路径都代表一个数字：
>
> - 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。
>
> 计算从根节点到叶节点生成的 **所有数字之和** 。
>
> **叶节点** 是指没有子节点的节点。
>
>  **示例 ：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230223004454.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [4,9,0,5,1]
> 输出：1026
> 解释：
> 从根到叶子节点路径 4->9->5 代表数字 495
> 从根到叶子节点路径 4->9->1 代表数字 491
> 从根到叶子节点路径 4->0 代表数字 40
> 因此，数字总和 = 495 + 491 + 40 = 1026
> ```

##### 分析:

深度优先递归遍历每个节点, 统计所有从根节点到叶子节点的路径整数, 最后求和

```python
class Solution:
    def sumNumbers(self, root: Optional[TreeNode]) -> int:
        def dfs(root: Optional[TreeNode], pathSum: int):
            if not root:
                return
            pathSum = pathSum * 10 + root.val
            if not root.left and not root.right:
                # 闭包不能直接修改嵌套函数外的变量值, 
                # 所以这里allSums不能是一个int
                allSums.append(pathSum)
            if root.left:
                dfs(root.left, pathSum)
            if root.right:
                dfs(root.right, pathSum)

        allSums = []
        dfs(root, 0)
        return sum(allSums)
```





#### [112. 路径总和](https://leetcode.cn/problems/path-sum/)

> 难度简单1113
>
> 给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。
>
> **叶子节点** 是指没有子节点的节点。

##### 分析

本题和上一题差不多, 可以通过`深度优先遍历(前序遍历)`或者`广度优先遍历`判断. 每次遍历到叶子节点时判断是否当前和等于目标值, 如果等于, 则返回`True`, 否则则返回`False` .

深度优先遍历递归版本:

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:

        def dfs(node, cur_sum) -> bool:
            if not node:
                return False
            
            cur_sum += node.val 
            # 当前是叶子结点, 且当前路径和等于目标, 则返回
            if not node.left and not node.right:
                if cur_sum == targetSum:
                    return True
                else:
                    return False
            
            return dfs(node.left, cur_sum) or dfs(node.right, cur_sum)
        
        return dfs(root, 0)
```

广度优先遍历迭代版本:

```python
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        if not root:
            return False
        
        nodes_q = [(root, 0)]
        while nodes_q:
            next_level = []
            for node,cur_sum in nodes_q:
                cur_sum += node.val
                if not node.left and not node.right:
                    # 如果叶子节点路径和等于目标值, 则直接返回 True
                    # 反之, 如果不等于, 这里不能直接返回 False, 
                    # 还需要检查其他的叶子节点
                    if cur_sum == targetSum:
                        return True
                if node.left:
                    next_level.append((node.left, cur_sum))
                if node.right:
                    next_level.append((node.right, cur_sum))
            nodes_q = next_level
        # 遍历完所有的节点都没有找到符合的, 则返回 False
        return False
```

#### [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)

> 难度中等909
>
> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> **叶子节点** 是指没有子节点的节点。
>
> **示例: **
>
> ```
> 输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
> 输出：[[5,4,11,2],[5,8,4,5]]
> ```

##### 分析

本题类似上一题 *112 路径总和*, 这不过这里需要输出具体的路径.

下面以深度优先遍历的递归实现为解答, 广度优先遍历也是可以的.

```python
# 开销较大的版本
from copy import copy
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []

        def dfs(node: Optional[TreeNode], cur_sum: int, prefix: List):
            # 这里增加一个形参List, 用来保存当前的路径
            if not node:
                return
            cur_sum += node.val
            prefix.append(node.val)
            if not node.left and not node.right:
                if cur_sum == targetSum:
                    res.append(prefix)
            # 这里必须copy一下
            dfs(node.left, cur_sum, copy(prefix))
            dfs(node.right, cur_sum, copy(prefix))
        
        dfs(root, 0, [])
        return res
```

注意到上面的解答虽然正确, 但是每次递归都需要复制一次路径列表, 开销很大, 这里可以使用一个 `路径栈` 来保存每次递归的当前路径, 并在递归后弹栈恢复状态, 这样可以大大减少开销. 

注意到当向`res`保存具体的结果时, 还是需要复制一次的.

```python
# 优化后的版本
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        res = []
        # 路径栈
        path = []
        def dfs(node: Optional[TreeNode], cur_sum: int):
            if not node:
                return
            cur_sum += node.val
            # 当前节点入栈
            path.append(node.val)
            if not node.left and not node.right:
                if cur_sum == targetSum:
                    # path[:] 返回一个path全量切片, 等同于 copy(path)
                    res.append(path[:])
            dfs(node.left, cur_sum)
            dfs(node.right, cur_sum)
            # 当前节点出栈
            path.pop()
        
        dfs(root, 0)
        return res
```

#### [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

> 难度中等1543
>
> 给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。
>
> **路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230221174950.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
> 输出：3
> 解释：和等于 8 的路径有 3 条，如图所示。
> ```

##### 分析

###### 双重递归(暴力穷举)

首先想到的解法是穷举所有的可能, 这里需要借助两层递归:

+ 内层递归(`nodeSum`): 访问每一个节点`node`, 检测以`node`为起始节点且向下延深的路径有多少种, 并返回
+ 外层递归(`pathSum`): 遍历每一个节点, 在每一个节点上调用内层递归计算该节点上可能的路径数量，然后将这些路径数目加起来即为返回结果。



```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        """外层递归"""
        if not root:
            return 0
        # 前序遍历
        ret = self.nodeSum(root, targetSum)
        # 注意下面两个是 pathSum !!
        ret += self.pathSum(root.left, targetSum)
        ret += self.pathSum(root.right, targetSum)
        return ret
    
    def nodeSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        """内层递归, 使用"减"而不是"加"的方式可以减少一个参数 """
        if not root:
            return 0
        # 前序遍历
        ret = 0
        if root.val == targetSum:
            ret += 1
        # 注意这里的 targetSum - root.val
        ret += self.nodeSum(root.left, targetSum - root.val)
        ret += self.nodeSum(root.right, targetSum - root.val)
        return ret
```

+ 时间复杂度: $O(N^2)$,  $N$ 为该二叉树节点的个数。对于每一个节点，求以该节点为起点的路径数目时，则需要遍历以该节点为根节点的子树的所有节点，因此求该路径所花费的最大时间为 $O(N)$, 我们会对每个节点都求一次以该节点为起点的路径数目，因此时间复杂度为 $O(N^2)$ .
+ 空间复杂度: $O(N)$

###### `前缀和(prefix sum)解法`

上面的解法采用暴力求解, 存在很多重复计算. 这里可以使用`前缀和`来减少计算量.

`前缀和(prefix sum)` 就是到达当前元素的路径上, 当前位置之前所有元素的和.

在二叉树中, 从根节点出发, 到达某个叶子节点的路径有且只有一条(**不存在环**). 在这个路径下, 如果两个节点的`前缀和`相同, 则说明这两个节点之间的元素之和(**路径和**)为零. 换而言之, 如果节点A的前缀和和节点B的前缀和相差`target`, 则说明节点A和节点B之间的元素之和(**路径和**)为`target`.

我们使用一个`hashMap`, 其`key`为`前缀和`取值, `value`为对应的节点数量.

每深度遍历一个节点, 就更新该节点的前缀和. 当抵达当前节点B时, 首先累加前缀和得到`curSum`, 然后查找在当前路径的前缀和上, 有没有前缀和等于`curSum-target`的节点, 如果存在节点A符合条件, 则说明从节点A到节点B的路劲之和等于`target`. 

将计数变量加上满足前缀和等于`curSum-target`的节点的数量, 然后递归进入左右子树. 

当左右子树遍历完成后, 需要回到当前层, 此时需要将当前节点添加的`前缀和`去除, 避免`回溯`之后影响上一层.

> 1. In order to optimize from the brutal force solution, we will have to think of a clear way to memorize the intermediate result. Namely in the brutal force solution, we did a lot repeated calculation. For example `1->3->5`, we calculated: 1, 1+3, 1+3+5, 3, 3+5, 5.
> 2. This is a classical 'space and time tradeoff': we can create a dictionary (named `cache`) which saves all the path sum (from root to current node) and their frequency.
> 3. Again, we traverse through the tree, at each node, we can get the `currPathSum` (from root to current node). If within this path, there is a valid solution, then there must be a `oldPathSum` such that `currPathSum - oldPathSum = target`.
> 4. We just need to add the frequency of the `oldPathSum` to the result.
> 5. During the DFS break down, we need to -1 in `cache[currPathSum]`, because this path is not available in later traverse.

代码实现如下: 

```python
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> int:
        # 定义前缀和字典, 
        # 注意:初始时放入一个前缀和为0的key,其取值为1
        cache = {0 : 1}
        return self.dfs(root, targetSum, cache, 0)

    def dfs(self, root: Optional[TreeNode], targetSum: int, cache: Dict[int, int], curPrefixSum: int) -> int:
        if not root:
            return 0
        # 计算当前节点的前缀和
        curPrefixSum += root.val
        # 计算当前节点前缀和和目标值之差, 这个值可能属于于当前节点之前的节点
        oldPrefixSum = curPrefixSum - targetSum
        # 初始化计数变量
        ret = cache.get(oldPrefixSum, 0)
        # 更新前缀和字典
        cache[curPrefixSum] = cache.get(curPrefixSum, 0) + 1
        # 递归计算左右子树
        ret += self.dfs(root.left, targetSum, cache, curPrefixSum)
        ret += self.dfs(root.right, targetSum, cache, curPrefixSum)
        # **注意: ** 在递归完左右子树之后, 必须把当前的前缀和cache计算-1, 
        # 因为马上要递归处理上一层, 不能影响回溯后的状态
        cache[curPrefixSum] -= 1
        # 返回结果
        return ret
```

> 注意上面的`dfs`也可以作为`pathSum`的嵌套函数, 这样可以减少函数签名的参数数量.

时间复杂度: $O(N)$

空间复杂度: $O(N)$



#### [666. 路径总和 IV](https://leetcode.cn/problems/path-sum-iv/)

难度中等57

对于一棵深度小于 `5` 的树，可以用一组三位十进制整数来表示。对于每个整数：

- 百位上的数字表示这个节点的深度 `d`，`1 <= d <= 4`。
- 十位上的数字表示这个节点在当前层所在的位置 `P`， `1 <= p <= 8`。位置编号与一棵满二叉树的位置编号相同。
- 个位上的数字表示这个节点的权值 `v`，`0 <= v <= 9`。

给定一个包含三位整数的 **升序** 数组 `nums` ，表示一棵深度小于 `5` 的二叉树，请你返回 *从根到所有叶子结点的路径之和* 。

**保证** 给定的数组表示一个有效的连接二叉树。



### 非自顶向下

#### [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

> 难度简单1244
>
> 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
>
>  **示例 :**
> 给定二叉树
>
> ```
>           1
>          / \
>         2   3
>        / \     
>       4   5    
> ```
>
> 返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
>
>  **注意：**两结点之间的路径长度是以它们之间边的数目表示

##### **待完善**





#### [面试题 04.12. 求和路径](https://leetcode.cn/problems/paths-with-sum-lcci/)

> 难度中等127
>
> 给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。
>
> **示例:**
> 给定如下二叉树，以及目标和 `sum = 22`，
>
> ```
>               5
>              / \
>             4   8
>            /   / \
>           11  13  4
>          /  \    / \
>         7    2  5   1
> ```
>
> 返回:
>
> ```
> 3
> 解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]
> ```

<todo>

#### [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)

> 难度中等754
>
> 给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。
>
> **两个节点之间的路径长度** 由它们之间的边数表示。
>
>  
>
> **示例 1:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222235746.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [5,4,5,1,1,5]
> 输出：2
> ```
>
> **示例 2:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222235754.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,4,5,4,4,5]
> 输出：2
> ```
>

<todo>





#### [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)

> 难度困难1854
>
> **路径** 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。
>
> **路径和** 是路径中各节点值的总和。
>
> 给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。
>
> **示例 ：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222235926.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [-10,9,20,null,null,15,7]
> 输出：42
> 解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
> ```

##### **待完善**

> 「力扣」第 53 题（最大子序和）是「力扣」第 124 题（二叉树的最大路径和）的线性版本，它们的状态设计思想和状态转移是类似的



>[【视频】彻底掌握直径 DP！从二叉树到一般树！（Python/Java/C++/Go） - 二叉树中的最大路径和 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/shi-pin-che-di-zhang-wo-zhi-jing-dpcong-n9s91/)



#### [1740. 找到二叉树中的距离](https://leetcode.cn/problems/find-distance-in-a-binary-tree/)

难度中等20收藏分享切换为英文接收动态反馈

给定一棵二叉树的根节点 `root` 以及两个整数 `p` 和 `q` ，返回该二叉树中值为 `p` 的结点与值为 `q` 的结点间的 **距离** 。

两个结点间的 **距离** 就是从一个结点到另一个结点的路径上边的数目。



## 判断对称二叉树

> 这类题目典型特点就是需要 *同时遍历两棵树* .

#### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

> 难度简单2278
>
> 给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

##### 分析

###### 递归解法

首先想清楚，判断对称二叉树要比较的是哪两个节点，**要比较的可不是左右节点**！

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的，理解这一点就知道了**其实我们要比较的是两个树（这两个树是根节点的左右子树）**，所以在递归遍历的过程中，也是要**同时遍历两棵树**。

此时需要比较两个节点的情况, 首先是两个节点中存在空节点的情况:

+ 左右节点都为空, 此时对称, 返回 `True`;
+ 左右节点有一个为空, 此时不对称, 返回 `False`;

其次是左右节点都不为空的情况, 此时需要进一步比较两个节点的取值:

如果两个节点的取值相同, 还要进一步判断左树的左子节点和右树的右子节点是够对称, 同时还要求左树的右子节点和右树的左子节点对称. 如果上述三个条件同时满足, 则此时 对称, 返回 `True`; 否则不对称, 返回 `False`.

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True

        def helper(left: Optional[TreeNode], right: Optional[TreeNode]) -> bool:
            # 左树和右树都为空, 则返回 True
            if left is None and right is None:
                return True
            # 左树和右树中只有一个为空, 则返回 False
            elif left is None or right is None:
                return False
            # 如果左树右树都不为空, 还要看左树的左节点和右树的右节点, 
            # 以及左树的右节点和右树的左节点 是否是对称的;
            # 只有这三个条件都满足, 才能返回True, 否则, 返回False
            elif (left.val == right.val 
                and helper(left.left, right.right) 
                and helper(left.right, right.left)):
                return True
            else:
                return False
        
        return helper(root, root)
```

###### 迭代解法

本题也可以通过迭代方式判断, 逐层将两个待判断的节点放入List, 并`逐对取出`判断. 注意这不是层序遍历.

```python
class Solution:
    def isSymmetric(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        # 开始时先将根节点的左子节点和右子节点放入 List, 
        # 作为初始判断的第一对节点
        nodes_q = [root.left, root.right]

        while nodes_q:
            # 注意这里使用的是List, 
            # pop()返回的实际是最右侧的元素
            # 不过这里取出最右侧或者最左侧的元素都可以, 
            # 但是必须成对保存, 成对取出
            # 这里使用队列(有popleft方法)或者列表都可以
            node_a = nodes_q.pop()
            node_b = nodes_q.pop()
			
            # 循环判读时只判读为False的情况, 如果遇到False, 则直接返回
            if node_a is None and node_b is None:
                continue
            elif node_a is None or node_b is None:
                return False
            elif node_a.val != node_b.val:
                return False
            # 这里压入两对待比较的节点, 分别是:
            # + 左树的左子节点 和 右树的右子节点;
            # + 左树的右子节点 和 右树的左子节点;
            nodes_q.append(node_a.left)
            nodes_q.append(node_b.right)
            nodes_q.append(node_a.right)
            nodes_q.append(node_b.left)
        # 当循环结束时, 所有的待判断节点都已经判断了, 
        # 没有非对称的节点对, 则此时表示整个树是对称的
        return True
```

#### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

> 难度简单967
>
> 给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
> 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

##### 分析

本题类似判断对称二叉树, 唯一差别就是本题判断的是两个树的相同位置的节点是否相同, 而不是对称位置的节点.

对*101 对称二叉树*的代码稍微修改即可:

```python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        
        def helper(a: Optional[TreeNode], b: Optional[TreeNode]) -> bool:
            if not a and not b:
                return True
            elif not a or not b:
                return False
            elif (a.val == b.val
                # 本题判断的是两个树的相同位置的节点是否相同
                and helper(a.left, b.left)
                and helper(a.right, b.right)
            ):
                return True
            else:
                return False
        
        return helper(p, q)
```

#### [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)

> 难度简单871
>
> 给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。
>
> 二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。
>
> **示例: **
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230220212826.jpeg" alt="img" style="zoom: 50%;" />
>
> ```
> 输入：root = [3,4,5,1,2], subRoot = [4,1,2]
> 输出：true
> ```

##### 分析

最直接的想法就是 首先按照*100 相同的树* , 定义一个判断两个节点是否是相同的树的方法, 然后遍历目标`tree`的所有节点, 逐个和`subTree`做判断, 直到遇到`True`或者遍历完为止.

下面的实现中采用了 迭代版本的层序遍历, 你也可以换为其他的遍历方法实现.

```python
class Solution:
    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:

        def is_same_tree(tree_a: Optional[TreeNode], tree_b: Optional[TreeNode]) -> bool:
            """
            	判断两个树是否相同. leetcode 100 相同的树
            """
            if not tree_a and not tree_b:
                return True
            elif not tree_a or not tree_b:
                return False
            elif tree_a.val != tree_b.val:
                return False
            elif is_same_tree(tree_a.left, tree_b.left) and is_same_tree(tree_a.right, tree_b.right):
                return True
            else:
                return False

        # 迭代实现 层序遍历, 逐个节点判断是否是相同的树
        nodes_q = [root]
        while nodes_q:
            next_level = []
            for node in nodes_q:
                if is_same_tree(node, subRoot):
                    return True
                if node:
                    next_level.append(node.left)
                    next_level.append(node.right)
            nodes_q = next_level
        
        return False
```

> 注意, 上面本质是暴力求解, 不是 最优解!
>
> 最优解是 `深度优先搜索序列上做串匹配`. 
>
> 题解见:  https://leetcode.cn/problems/subtree-of-another-tree/solution/ling-yi-ge-shu-de-zi-shu-by-leetcode-solution/
>
> > 在判断「s 的深度优先搜索序列包含 t 的深度优先搜索序列」的时候，可以暴力匹配，也可以使用 KMP 或者 Rabin-Karp算法



#### [617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)

> 难度简单1165
>
> 给你两棵二叉树： `root1` 和 `root2` 。
>
> 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。
>
> 返回合并后的二叉树。
>
> **注意:** 合并过程必须从两个树的根节点开始。
>
>  
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222230439.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
> 输出：[3,4,5,5,4,null,7]
> ```

##### 分析

在两个树的对应节点上做深度优先遍历即可, 每次递归合并一个节点, 解法如下:

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root1 and not root2:
            # 如果两个待合并的节点都为空, 直接返回 空节点
            return None
        elif root1 and not root2:
            # 其中一个待合并节点为空, 则直接返回另一个非空节点
            return root1
        elif not root1 and root2:
            # 其中一个待合并节点为空, 则直接返回另一个非空节点
            return root2
        # 如果两个待合并的节点都 不为空,
        # 则先合并取值, 然后依次递归合并左右子树
        root1.val += root2.val
        root1.left = self.mergeTrees(root1.left, root2.left)
        root1.right = self.mergeTrees(root1.right, root2.right)
        return root1
```

简化写法:

Python 中的二元逻辑运算逻辑如下:

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222231238.png" alt="image-20230222231237902" style="zoom: 67%;" />

即, `or`和`and`返回的是`操作数(operand)`, 而不是一个布尔值. 利用这个性质, 我们可以进一步简化上面的代码:

```python
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        if root1 and root2:
            # 如果两个待合并的节点都 不为空,
            # 则先合并取值, 然后依次递归合并左右子树
            root1.val += root2.val
            root1.left = self.mergeTrees(root1.left, root2.left)
            root1.right = self.mergeTrees(root1.right, root2.right)
        # 如果root1不为空(包含两个节点都不为空, 或者只有root2为空的两个情况), 则返回root1,
        # 否则则返回 root2
        return root1 or root2
```

## 满二叉树/完全二叉树

#### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

> 难度中等877
>
> 给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。
>
> [完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 $1$ ~ $2^h$ 个节点。

##### 分析

本题可以忽略完全二叉树这个条件, 直接使用深度优先遍历或者层序遍历统计节点数量, 这样比较简单, 但是这样就忽视了 完全二叉树的特点.

假如题目要求必须利用 完全二叉树 的性质, 则可以如下解答: 

`完全/满二叉树`有如下性质: 

+ 如果一个`完全二叉树`的`最左侧节点`的层数等于`最右侧节点`的层数, 则该二叉树是一个 `满二叉树`.

+ 如果一个 `满二叉树` 的最大层数为 $h$, 则该二叉树的 节点总数为 $2^{h+1}-1$ .

+ 如果一个 `完全二叉树`不是一个`满二叉树`, 则分别递归左右子树, 等一定深度时, 最终左右子树都将是 `满二叉树`

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230221000622.png" alt="image-20230221000622302" style="zoom:35%;" />

根据上面的特点, 我们可以写出一个递归计算完全二叉树节点总数的解法:

```python
class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        
        left_level = right_level = 0
        # 计算最左侧节点的深度
        left_node = root
        while left_node.left:
            left_node = left_node.left
            left_level += 1
        # 计算最右侧节点的深度
        right_node = root
        while right_node.right:
            right_node = right_node.right
            right_level += 1
        
        if left_level == right_level:
            # 左右最大层数相同, 且这是一个完全二叉树, 故此时是一个 满二叉树
            # 满二叉树的性质, 节点总数 = 2^(最大深度+1)-1 = (2<<最大深度)-1
            return (2 << left_level) - 1
        else:
            # 不是满二叉树, 则分别递归统计左右子树的节点总数, 然后相加
            return self.countNodes(root.left) + self.countNodes(root.right) + 1
```

#### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)

难度中等150收藏分享切换为英文接收动态反馈

**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。

实现 `CBTInserter` 类:

- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)` 向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；
- `CBTInserter.get_root()` 将返回树的头节点。

## 平衡二叉树

#### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)

> 难度简单1245
>
> 给定一个二叉树，判断它是否是高度平衡的二叉树。
>
> 本题中，一棵高度平衡二叉树定义为：一个二叉树*每个节点* 的左右两个子树的**高度差的绝对值不超过 1** 。

##### 分析

> 类似题目: *104 二叉树的最大深度*

本题需要比较每个节点的左右子树的高度差, 因此使用深度优先的递归实现比较自然直观. 

根据平衡二叉树的定义(左右两个子树的**高度差的绝对值不超过 1**), 容易想到, 让每个递归函数返回左右子树的高度差的绝对值. 但是**高度差的绝对值不适合作为递归函数的返回值**(如果子树只返回子树的高度差, 那么父树在计算高度差时还需要子树的各自高度). 

因此, 更适合的方式是**让递归返回左右子树各自的高度**, 然后在递归函数中判断高度差, 如果高度差的绝对值超过`1`, 这说明不是平衡二叉树, **此时需要返回一个特殊值**. 

参考 *104 二叉树的最大深度* 的实现, 可知, 递归函数的正常返回值`>=0`(空树的高度为`0`), 因此, 这里取负数`-1` 作为不平衡时的特殊返回值.

另外, 如果一个子树是不平衡的, 那么这个树肯定是不平衡的. 因此, 在计算左右子树的高度时, 如果子递归的返回值是`-1`, 则不需要进一步比较高度差, 直接返回 `-1` 即可.

综上, 可以得到如下的计算过程:

+ 递归计算每个子树的高度, 如果不平衡, 则返回 `-1`; 
+ 所有递归结束后, 如果返回值是`-1`, 则表示整个树不平衡; 否则树是平衡树, 且此时的返回值为树的`高度`;
+ 如果节点是一个空树, 则返回高度为`0`;
+ 如果左右子树的递归返回值为`-1`, 则说明整个树不平衡, 直接返回 `-1`;
+ 如果左右子树平衡, 则比较左右子树的高度差的绝对值, 如果大于`1`, 则表示不平衡, 返回`-1`;
+ 如果左右子树的高度差绝对值满足条件, 这说明当前递归树平衡, 返回新的`高度`;

```python
class Solution:
    def isBalanced(self, root: Optional[TreeNode]) -> bool:

        def get_tree_height(root: Optional[TreeNode]) -> int:
            if not root:
                return 0
            
            left_h = get_tree_height(root.left)
            if left_h == -1:
                return -1

            right_h = get_tree_height(root.right)
            if right_h == -1:
                return -1

            if abs(left_h - right_h) > 1:
                return -1
            else:
                return max(left_h, right_h) + 1

        return get_tree_height(root) != -1 
```

## 构造二叉树

#### [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> 难度中等940
>
> 给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。
>
>  
>
> **示例 1:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222000516.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
> 输出：[3,9,20,null,null,15,7]
> ```

##### 分析

中序遍历的顺序是: `左,中,右`

后序遍历的顺序是: `左,右,中`

据此我们可以设计一个递归重建二叉树的算法, 具体过程如下:

```
TreeNode* buildTree(中序遍历数组, 后序遍历数组):
	(1) 如果 后序数组为空, 则返回 Null (空节点);
	(2) 由 后序数组 的最后一个元素确定当前的 根节点取值, 重建根节点 root (左右子树为Null);
	(3) 在 中序数组 中查找取值等于root.val的元素索引, 
		使用这个索引将 中序数组 分割为 左中序数组 和 右中序数组 (两个都不包含root);
	(4) 计算得到 左中序数组 的长度, 这个长度也是左子树节点的数量, 
		使用这个长度将 后序数组 分割为 左后序数组 和 右后序数组 (两个都不包含root);
	(5) root.left = buildTree(左中序数组, 左后序数组);
	(6) root.right = buildTree(右中序数组, 右后序数组);
	(7) return root;
```

上述过程的Python递归实现如下:

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        # 如果后序数组为空, 则返回空节点
        if not postorder:
            return None
        # 用后序数组的最后一个值作为根节点的值
        root = TreeNode(postorder[-1])
        # 在中序数组找到根节点值的索引(数组无重复值), 
        # 然后划分为 左中序 和 右中序 (两个都不包含根节点)
        index = 0
        for i, val in enumerate(inorder):
            if val == root.val:
                index = i
                break
        # 注意python切片是 左闭右开
        left_inorder = inorder[ : index]
        right_inorder = inorder[index + 1 : ]
        leftWidth = len(left_inorder)
        # 根据中序的切分, 我们可以直到左子树的节点数量,
        # 据此可以进一步切分后序数组为 左后序 和 右后序 (两个都不包含根节点)
        left_postorder = postorder[ : leftWidth]
        right_postorder = postorder[leftWidth : -1]
        # 然后在两个切分后的序列数组上继续递归
        root.left = self.buildTree(left_inorder, left_postorder)
        root.right = self.buildTree(right_inorder, right_postorder)
        return root
```

提交后可以发现, 上述实现的执行用时和内存消耗都比较大. 这主要是因此, 上面的版本在递归传递参数时, 每次都需要切片数组并传递, 开销很大. 

为此, 我们可以使用两个开始指针和结束指针指向切分区间, 避免多次传递数组. 同时还可以将中序数组的值到索引的映射提前保存到一个 hash map 中, 避免每次递归都要循环查询.

> 上面的版本更容易理解, 下面的版本效率更高.

优化后的版本如下:

```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> Optional[TreeNode]:
        def helper(
            inStartIdx: int, inEndIdx: int, postStartIdx: int, postEndIdx: int
        ) -> Optional[TreeNode]:
            """
            	inStartIdx, inEndIdx: 标识中序数组的范围, 左闭右闭
            	postStartIdx, postEndIdx: 标识后序数组的范围, 左闭右闭
            """
            # 如果后序数组为空, 则返回空节点
            # 开始位置索引大于结束位置索引, 说明当前范围为空
            if postStartIdx > postEndIdx:
                return None
            # 用后序数组的最后一个值作为根节点的值
            root = TreeNode(postorder[postEndIdx])
            # 在中序数组找到根节点值的索引(数组无重复值),
            rootIdx = inorder_map[root.val]
            # 然后划分为 左中序 和 右中序 (两个都不包含根节点);
            # 注意这里需要跳过 根节点, 
            # 所以 leftInEndIdx = rootIdx - 1, rightInStartIdx = rootIdx + 1
            leftInStartIdx, leftInEndIdx = inStartIdx, rootIdx - 1
            rightInStartIdx, rightInEndIdx = rootIdx + 1, inEndIdx
            # 根据中序的切分, 我们可以直到左子树的节点数量,
            leftWidth = leftInEndIdx - leftInStartIdx + 1
            # 据此可以进一步切分后序数组为 左后序 和 右后序 (两个都不包含根节点)
            leftPostStartIdx, leftPostEndIdx = (
                postStartIdx,
                postStartIdx + leftWidth - 1,
            )
            rightPostStartIdx, rightPostEndIdx = leftPostEndIdx + 1, postEndIdx - 1
            # 然后在两个切分后的序列数组上继续递归
            root.left = helper(
                leftInStartIdx, leftInEndIdx, leftPostStartIdx, leftPostEndIdx
            )
            root.right = helper(
                rightInStartIdx, rightInEndIdx, rightPostStartIdx, rightPostEndIdx
            )
            return root
		# 将中序数组的值到索引的映射提前保存到一个 hash map 中
        inorder_map = {v: i for i, v in enumerate(inorder)}
        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)
```

> **注意:** 也可以使用`迭代`实现, 但是本题的迭代实现不太直观.



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> 难度中等1874
>
> 给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。
>
>  
>
> **示例 1:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230222000616.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
> 输出: [3,9,20,null,null,15,7]
> ```

##### 分析

> 本题和 *106 从中序与后序遍历序列构造二叉树* 非常相似, 因此可以直接套用上一题的解法.

中序遍历顺序为: `左,中,右`

前序遍历顺序为: `中,左,右`

据此我们可以设计一个递归重建二叉树的算法, 具体过程如下:

```
TreeNode* buildTree(中序遍历数组, 后序遍历数组):
	(1) 如果 前序数组 为空, 则返回 Null (空节点);
	(2) 由 前序数组 的首个元素确定当前的 根节点取值, 重建根节点 root (左右子树为Null);
	(3) 在 中序数组 中查找取值等于root.val的元素索引, 
		使用这个索引将 中序数组 分割为 左中序数组 和 右中序数组 (两个都不包含root);
	(4) 计算得到 左中序数组 的长度, 这个长度也是左子树节点的数量, 
		使用这个长度将 前序数组 分割为 左前序数组 和 右前序数组 (两个都不包含root);
	(5) root.left = buildTree(左中序数组, 左前序数组);
	(6) root.right = buildTree(右中序数组, 右前序数组);
	(7) return root;
```

最终的递归解法如下:

```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:
        def helper(
            preStartIdx: int, preEndIdx: int, inStartIdx: int, inEndIdx: int
        ) -> Optional[TreeNode]:
            if preStartIdx > preEndIdx:
                # 当前前序区间为空, 返回空节点
                return None
            # 当前 前序区间 的首个元素就是根节点
            root = TreeNode(preorder[preStartIdx])
            # 在 中序区间 中找到根节点的索引
            rootIdx = inorder_map[root.val]
            # 使用 根节点索引 将 中序区间 分割为 左右两个子区间 (不含根节点)
            leftInStartIdx, leftInEndIdx = inStartIdx, rootIdx - 1
            rightInStartIdx, rightInEndIdx = rootIdx + 1, inEndIdx
            # 从而可以知道当前根节点的左子树的节点数量(=左中序区间的长度)
            leftWidth = leftInEndIdx - leftInStartIdx + 1
            # 使用左中序区间长度, 可以进一步将 前序区间 分割为 左右两个子区间 (不含根节点)
            leftPreStartIdx, leftPreEndIdx = preStartIdx + 1, preStartIdx + leftWidth
            rightPreStartIdx, rightPreEndIdx = leftPreEndIdx + 1, preEndIdx
            # 继续在左右子区间上递归
            root.left = helper(
                leftPreStartIdx, leftPreEndIdx, leftInStartIdx, leftInEndIdx
            )
            root.right = helper(
                rightPreStartIdx, rightPreEndIdx, rightInStartIdx, rightInEndIdx
            )
            return root

        inorder_map = {v: i for i, v in enumerate(inorder)}
        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)
```

#### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)

> 难度中等632
>
> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
>
> 1. 创建一个根节点，其值为 `nums` 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
>
> 返回 *`nums` 构建的* ***最大二叉树\*** 。
>
>  
>
> **示例 ：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230223011651.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：nums = [3,2,1,6,0,5]
> 输出：[6,3,5,null,2,0,null,null,1]
> ```

##### 分析

###### 递归构建树

按照题目描述, 可以以类似 *106. 从中序与后序遍历序列构造二叉树* 的递归方式, 递归构建一个树:

```python
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -> Optional[TreeNode]:
        def buildTree(startIdx: int, endIdx: int) -> Optional[TreeNode]:
            if startIdx > endIdx:
                # 区间为空或者不合法, 直接返回 空节点
                return None
            # 找到区间内最大值得索引
            maxValIdx = startIdx
            for i in range(startIdx+1, endIdx+1):
                if nums[i] > nums[maxValIdx]:
                    maxValIdx = i
            # 使用最大值构建root
            root = TreeNode(nums[maxValIdx])
            # 使用最大值索引划分左右区间
            # 这里得到的区间索引可能不合法, 在递归开始检查
            leftStartIdx, leftEndIdx = startIdx, maxValIdx - 1
            rightStartIdx, rightEndIdx = maxValIdx + 1, endIdx
            # 继续递归构建子树
            root.left = buildTree(leftStartIdx, leftEndIdx)
            root.right = buildTree(rightStartIdx, rightEndIdx)
            return root
            
        return buildTree(0, len(nums) - 1)
```

时间复杂度: $O(n^2)$ **怎么分析??**

空间复杂度: $O(n)$

###### `线段树`解法

###### `单调栈`解法

> [单调栈 - OI Wiki](https://oi-wiki.org/ds/monotonous-stack/)



#### [1028. 从先序遍历还原二叉树](https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/)

> 难度困难233
>
> 我们从二叉树的根节点 `root` 开始进行深度优先搜索。
>
> 在遍历中的每个节点处，我们输出 `D` 条短划线（其中 `D` 是该节点的深度），然后输出该节点的值。（*如果节点的深度为 `D`，则其直接子节点的深度为 `D + 1`。根节点的深度为 `0`）。*
>
> 如果节点只有一个子节点，那么保证该子节点为左子节点。
>
> 给出遍历输出 `S`，还原树并返回其根节点 `root`。



#### [1597. 根据中缀表达式构造二叉表达式树](https://leetcode.cn/problems/build-binary-expression-tree-from-infix-expression/)

> 难度困难27
>
> **二叉表达式树** 是一种表达算术表达式的二叉树。二叉表达式树中的每一个节点都有零个或两个子节点。 叶节点（有 0 个子节点的节点）表示操作数，非叶节点（有 2 个子节点的节点）表示运算符： `'+'` （加）、 `'-'` （减）、 `'*'` （乘）和 `'/'` （除）。
>
> 对于每一个运算符为 `o` 的非叶节点，对应的 **[中缀表达式](http://baike.baidu.com/item/中缀表达式/2725244?fr=aladdin)** 为 `(A o B)`，其中 `A` 是左子树所表达的表达式， `B` 是右子树所表达的表达式。
>
> 给定一个 **中缀表达式** 字符串 `s`，其中包含操作数、上面提到的运算符，以及括号 `'('` 与 `')'` 。
>
> 返回一个有效的 **二叉表达式树**，其 [**中序遍历**](http://baike.baidu.com/item/中序遍历/757281?fr=aladdin) 序列对应表达式 `s` 消除括号后的序列（详情参见下面的示例）*。*
>
> **注意，表达式的一般解析顺序适用于** `s`，即优先解析括号内的表达式，然后解析乘除法，最后解析加减法。
>
> 同时，操作数在 `s` 和树的中序遍历中 **出现顺序相同** 。

## 二叉搜索树

#### [700. 二叉搜索树中的搜索](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

> 难度简单371
>
> 给定**二叉搜索树**（BST）的根节点 `root` 和一个整数值 `val`。
>
> 你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。
>
> **示例 1:**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313161422.jpeg" alt="img" style="zoom:40%;" />
>
> ```
> 输入：root = [4,2,7,1,3], val = 2
> 输出：[2,1,3]
> ```

 ##### 分析:

本题考察二叉搜索树的**定义**:

> 二叉搜索树是一个有序树：
>
> - 若它的左子树不空，则**左子树上所有结点的值均小于它的根结点的值**；
> - 若它的右子树不空，则**右子树上所有结点的值均大于它的根结点的值**；
> - 它的左、右子树也分别为二叉搜索树

由上述定义, 可以写出以下的递归搜索过程:

递归实现如下:

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return None
        if root.val == val:
            return root
        elif val > root.val:
            return self.searchBST(root.right, val)
        else:
            return self.searchBST(root.left, val)
```

当然, 我们也可以使用 栈 将上述的递归改写为迭代. 但是*最为简单的实现方式是, 根据定义, 直接循环更新指针查找路径*:

```python
class Solution:
    def searchBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        while root:
            # 空节点, 此时退出循环, 路径不存在, 返回 null
            if not root:
                break
            if root.val == val:
                return root
            elif val > root.val:
                root = root.right
            else:
                root = root.left
        return None
```



#### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

> 难度中等1930
>
> 给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。
>
> **有效** 二叉搜索树定义如下：
>
> - 节点的左子树只包含 **小于** 当前节点的数。
> - 节点的右子树只包含 **大于** 当前节点的数。
> - 所有左子树和右子树自身必须也是二叉搜索树。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313161052.jpeg" alt="img" style="zoom: 50%;" />
>
> ```
> 输入：root = [2,1,3]
> 输出：true
> ```

 

##### 分析

**解法一: 根据定义递归判断**

刚看到这个题目, 最容易想到的解法就是根据定义来递归判断左右子树是否是一个二叉搜索树. 但这里面有一个**很容易犯的错误**, 就是容易简单地认为, 只需要递归判断左右子节点的值和根节点的值的关系即可了. 此时写出的程序无法在全部用例上通过, 错误的解法如下:

```python
class Solution:
    # 错误的解法!
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        if root.left:
            if root.left.val >= root.val:
                return False
        if root.right:
            if root.right.val <= root.val:
                return False
        if self.isValidBST(root.right) and self.isValidBST(root.left):
            return True
        else:
            return False
```

测试用例如下图所示:

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315135622.png" alt="image-20230315135615737" style="zoom:40%;" />



此时上述的错误解法会给出`True`的结果, 但是实际上这不是一个`BST`. 观察图中的`节点3`, 注意虽然其小于`父节点6`, 但是作为`根节点5`的右子树, 其取值不应该小于`根节点5`, 因此这不是一个`BST`.

根据上述分析, 我们可以得出, 要递归判断一个树是不是`BST`, 就要求:

+ 左子节点的值小于根节点的值, 同时还得大于一个 **下界值**, 这个下界值由父节点的父节点决定;
+ 右子节点的值大于根节点的值, 同时还得小于一个 **上界值**, 这个上界值由父节点的父节点决定;
+ 当递归开始时(指向树的根节点时), 下界时无穷小, 上界是无穷大;

由上述, 我们修改得到如下代码:

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:

        def check(root: Optional[TreeNode], lower: int, upper: int):
            if not root:
                return True
            if root.left:
                # 左子节点必须小于根节点取值, 同时大于 下界
                if root.left.val >= root.val or root.left.val <= lower:
                    return False
            if root.right:
                # 右子节点必须大于根节点取值, 同时小于 上界
                if root.right.val <= root.val or root.right.val >= upper:
                    return False
            # 检查右子树时更新 下界, 检查左子树时更新 上界
            if check(root.right, root.val, upper) and check(root.left, lower, root.val):
                return True
            else:
                return False
        
        return check(root, float("-inf"), float("inf"))
```

**解法二: 检查中序遍历序列**

上述解法一从定义入手, 递归判断左右子树是否满足条件, 但是需要注意更新上下界的取值, 有时候容易犯错.

这里我们利用二叉搜索树的一个重要性质: 

> `中序遍历`一个二叉搜索树可以得到一个节点值的*升序序列*.  
>
> **如果一个树的中序遍历序列不是升序序列, 那么它一定不是二叉搜索树!**

因此, 我们得到一个新的简单解法: 首先中序遍历二叉树, 得到中序遍历序列, 然后检查该序列是否是生序序列即可!

```python
class Solution:
    def isValidBST(self, root: Optional[TreeNode]) -> bool:
        if not root:
            return True
        nodes = []
        # 首先中序遍历(迭代实现), 保存到nodes中
        stack = []
        point = root
        while point or stack:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                node = stack.pop()
                nodes.append(node.val)
                point = node.right
        # 然后检查中序序列是否为升序:
        for i in range(1, len(nodes)):
            if nodes[i] <= nodes[i-1]:
                return False
        return True
```

> 这里也可以将 检查升序 和 中序遍历 结合在一个循环中完成!

#### [783. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/)

> **补充:**  [530. 二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/) 和  [783. 二叉搜索树节点最小距离](https://leetcode.cn/problems/minimum-distance-between-bst-nodes/) 是一个题目, 只不过 783 的题目题目起错了, 本题和距离没有任何关系.

> 难度简单249
>
> 给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。
>
> 差值是一个正数，其数值等于两值之差的绝对值。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313161237.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [4,2,6,1,3]
> 输出：1
> ```
>

 ##### 分析

> 遇到在二叉搜索树上求什么最值啊，差值之类的，就把它想成在一个**有序数组**上求最值，求差值，这样就简单多了

根据二叉搜索树的性质, 我们中序遍历二叉搜索树, 会得到一个 **升序序列**. 而本题要求计算BST中任意两节点之间的最小差绝对值, 因为在一个升序序列中, **最小的差值肯定是在相邻节点之间产生的**, 因此我们只需要遍历这个升序序列, 直到相邻节点的最差值即可.

```python
class Solution:
    def minDiffInBST(self, root: Optional[TreeNode]) -> int:
        vals = []
        # 中序遍历
        stack = []
        point = root
        while point or stack:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                node = stack.pop()
                vals.append(node.val)
                point = node.right
        # 判断相邻节点的最小差值
        minDiff = abs(vals[1] - vals[0])
        for i in range(1, len(vals)):
            minDiff = min(minDiff, abs(vals[i] - vals[i-1]))
        return minDiff
```

> 这里也可以将 计算最小差值 和 中序遍历 结合在一个循环中完成!



#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

> 难度中等2147
>
> 给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230316214043.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：n = 3
> 输出：5
> ```

##### 分析:

> 由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树(BST)** 的数量等于`卡塔兰数` $C_n$
>
> `卡塔兰数`的递推公式为: $C_{n+1} = \frac{2(2n+1)}{n+2}C_{n}$ 

根据`卡塔兰数`的递推公式, 可以写出如下解法:

```python
class Solution:
    def numTrees(self, n: int) -> int:
        if n == 0:
            return 1
        # C_{n+1} = 2(2n+1)/(n+2) * C_{n}
        prev = 1
        for i in range(n):
            cur = 2*(2*i+1)/(i+2) * prev
            prev = cur
        return int(prev)
```



#### [501. 二叉搜索树中的众数](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

> 难度简单607
>
> 给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/众数/44796)（即，出现频率最高的元素）。
>
> 如果树中有不止一个众数，可以按 **任意顺序** 返回。
>
> 假定 BST 满足如下定义：
>
> - 结点左子树中所含节点的值 **小于等于** 当前节点的值
> - 结点右子树中所含节点的值 **大于等于** 当前节点的值
> - 左子树和右子树都是二叉搜索树
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315153608.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [1,null,2,2]
> 输出：[2]
> ```

##### 分析:

> 这里其实不是一个严格符合定义的BST, 因此这里允许左右子节点等于父节点的值.

最**简单朴素**的想法就是, 把这个树当做是普通的二叉树, 首先遍历二叉树得到所有节点值, 在遍历时维护一个*计数哈希表Map*, 统计每个取值出现的次数. 当遍历完成时, 对这个哈希表按照取值降序排序, 从而得到最大出现次数, 然后将所有出现次数等于最大出现次数的值输出即可.  具体的实现如下:

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        # 统计出现次数的哈希表
        valCount = {}
        # 中序遍历并更新哈希表:
        # 这里也可以使用其他的遍历方式
        stack = []
        point = root
        while point or stack:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                node = stack.pop()
                # 更新哈希表
                valCount[node.val] = valCount.get(node.val, 0) + 1
                point = node.right
        # 对哈希表按照计数降序排序
        valMapItems = sorted(valCount.items(), key = lambda p:p[1], reverse = True)
        maxCount = valMapItems[0][1]
        res = []
        for val,count in valMapItems:
            if count < maxCount:
                break
            res.append(val)
        return res
```

上述实现无视了二叉搜索树的性质, 空间复杂度较大, 为 $O(n)$, 考虑利用二叉搜索树的性质, 减小空间复杂度.

二叉搜索树的一个重要性质就是: 其**中序遍历的序列是一个升序序列.** 也就是说, 本题中, *如果有相同取值的节点, 那么他们在中序序列中一定是连续的*. 例如 `[-1, 1, 1, 2, 2, 2, 3]`. 利用这个性质, 我们可以在中序遍历时得到每一个连续相同取值节点的数量`count`, 最终可以得到一个最大数量 `maxCount`, 从而得到结果.  不过这里需要在遍历中不断更新`count` 和 `maxCount`, 还需要输出`maxCount` 的对应节点值(可能有多个). 

这里有两种操作, 最简单的方式就是遍历两遍, 第一遍先得到`maxCount`, 第二遍再输出对应取值的节点. 另一种简洁的方式是在遍历时动态更新`maxCount`和结果数组. 具体的操作流程如下:

我们用`base`记录节点的取值; 用`count`记录当前数字的出现此时. 当遍历到一个新的节点时:

1. 首先更新`count`和`base`:
   +  如果该节点取值等于`base`, 则 `count`加一; 
   + 如果该节点取值不等于 `base`, 则更新`base`为当前节点取值, 同时`count`复位为一;
2. 再更新`maxCount`和结果数组`ans`:
   + 如果`count`等于`maxCount`, 则将当前节点值放入结果数组`ans`中;
   + 如果`count`大于`maxCount`, 则说明需要更新`maxCount`, 令`maxCount`等于`count`, 同时清空`ans`, 然后再将当前节点值放入`ans`;

代码实现如下, `update`函数实现了上述更新逻辑:

```python
class Solution:
    def findMode(self, root: Optional[TreeNode]) -> List[int]:
        if not root:
            return []
        
        self.base = None
        self.count = 0
        self.maxCount = 0
        self.ans = []
        
        def update(val: int):
            if val == self.base:
                self.count += 1
            else:
                self.base = val
                self.count = 1
            if self.count == self.maxCount:
                self.ans.append(val)
            elif self.count > self.maxCount:
                self.maxCount = self.count
                self.ans = [val]
        
        # 中序遍历 (这里必须是中序遍历):
        stack = []
        point = root
        while point or stack:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                node = stack.pop()
                # 更新:
                update(node.val)
                point = node.right

        return self.ans
```

> 上述的实现相比朴素实现, 简化了部分操作, 但是空间复杂度仍然为$O(n)$, 这主要是因为中序遍历的开销引起的. 为了进一步优化空间复杂度到$O(1)$, 可以进一步使用`Morris 中序遍历`. 



#### [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

> 难度中等454
>
> 给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。
>
> **注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。
>
>  
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315233038.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [4,2,7,1,3], val = 5
> 输出：[4,2,7,1,3,5]
> ```

##### 分析:

根据BST的定义, *仿照在BST中查找指定节点的方式 ( 题目: 700. 二叉搜索树中的搜索 ), 当路径的节点不存在时, 在对应位置完成指定节点插入即可.*

具体实现如下:

```python
class Solution:
    def insertIntoBST(self, root: Optional[TreeNode], val: int) -> Optional[TreeNode]:
        if not root:
            return TreeNode(val)
        node = root
        while node:
            if val > node.val:
                if node.right:
                    node = node.right
                else:
                    node.right = TreeNode(val)
                    break
            else:
                if node.left:
                    node = node.left
                else:
                    node.left = TreeNode(val)
                    break
        return root
```



#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)

> 难度中等
>
> 给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
> 一般来说，删除节点可分为两个步骤：
>
> 1. 首先找到需要删除的节点；
> 2. 如果找到了，删除它。
>
> 示例 1:
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230315234414.jpeg" alt="img" style="zoom:50%;" />
>
> ```
> 输入：root = [5,3,6,2,4,null,7], key = 3
> 输出：[5,4,6,2,null,null,7]
> 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
> 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
> 另一个正确答案是 [5,2,6,null,4,null,7]。
> ```

##### **待完善**



#### [669. 修剪二叉搜索树](https://leetcode.cn/problems/trim-a-binary-search-tree/)

> 难度中等776
>
> 给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。
>
> 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230316225351.jpeg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [1,0,2], low = 1, high = 2
> 输出：[1,null,2]
> ```

##### **待完善**





#### [776. 拆分二叉搜索树](https://leetcode.cn/problems/split-bst/)

> 难度中等123
>
> 给你一棵二叉搜索树（BST）的根结点 `root` 和一个整数 `target` 。请将该树按要求拆分为两个子树：其中一个子树结点的值都必须小于等于给定的目标值；另一个子树结点的值都必须大于目标值；树中并非一定要存在值为 `target` 的结点。
>
> 除此之外，树中大部分结构都需要保留，也就是说原始树中父节点 `p` 的任意子节点 `c` ，假如拆分后它们仍在同一个子树中，那么结点 `p` 应仍为 `c` 的父结点。
>
> 返回 *两个子树的根结点的数组* 。
>
> **示例 1：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230316230957.jpeg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [4,2,6,1,3,5,7], target = 2
> 输出：[[2,1],[4,3,6,null,null,5,7]]
> ```

##### **待完善**



#### [99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)

> 难度中等840
>
> 给你二叉搜索树的根节点 `root` ，该树中的 **恰好** *两个节点的值被错误地交换*。*请在不改变其结构的情况下，恢复这棵树* 。
>
> **示例 ：**
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230316232757.jpeg" alt="img" style="zoom:67%;" />
>
> ```
> 输入：root = [3,1,4,null,null,2]
> 输出：[2,1,4,null,null,3]
> 解释：2 不能在 3 的右子树中，因为 2 < 3 。交换 2 和 3 使二叉搜索树有效。
> ```

##### **待完善**





#### [108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

> 难度简单1258
>
> 给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。
>
> **高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
>
> ```
> 输入：nums = [-10,-3,0,5,9]
> 输出：[0,-3,9,-10,null,5]
> 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案
> ```

##### 分析

给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。

如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230427134809.png" alt="image-20230427134809343" style="zoom:45%;" />

直观地看，我们**可以选择中间数字作为二叉搜索树的根节点**，这样分给左右子树的数字个数相同或只相差一，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。

确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
        def helper(left, right):
            if left > right:
                return None

            # 总是选择中间位置左边的数字作为根节点
            mid = (left + right) // 2

            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root

        return helper(0, len(nums) - 1)
```



#### [538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

> **注意：**本题和 [1038. 从二叉搜索树到更大和树](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/) 相同

> 难度中等861
>
> 给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为**累加树**（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。
>
> 累加树: 将原二叉树的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和.
>
> 提醒一下，二叉搜索树满足下列约束条件：
>
> - 节点的左子树仅包含键 **小于** 节点键的节点。
> - 节点的右子树仅包含键 **大于** 节点键的节点。
> - 左右子树也必须是二叉搜索树。
>
> 示例 1：
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230316205000.png" alt="img" style="zoom:50%;" />
>
> ```
> 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
> 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
> ```



#### [255. 验证前序遍历序列二叉搜索树](https://leetcode.cn/problems/verify-preorder-sequence-in-binary-search-tree/)

> 难度中等176
>
> 给定一个 **无重复元素** 的整数数组 `preorder` ， *如果它是以二叉搜索树的**先序遍历**排列* ，返回 `true` 。

**示例 1：**

<img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313134510.jpeg" alt="img" style="zoom:67%;" />

```
输入: preorder = [5,2,1,3,6]
输出: true
```



#### [285. 二叉搜索树中的中序后继](https://leetcode.cn/problems/inorder-successor-in-bst/)

难度中等192

给定一棵二叉搜索树和其中的一个节点 `p` ，找到该节点在树中的中序后继。如果节点没有中序后继，请返回 `null` 。

节点 `p` 的后继是值比 `p.val` 大的节点中键值最小的节点。

 

**示例 1：**

![img](https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313161316.png)

```
输入：root = [2,1,3], p = 1
输出：2
解释：这里 1 的中序后继是 2。请注意 p 和返回值都应是 TreeNode 类型。
```



#### [230. 二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

难度中等712

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 个最小元素（从 1 开始计数）。

 

**示例 1：**

![img](https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230313161207.jpeg)

```
输入：root = [3,1,4,null,2], k = 1
输出：1
```

##### 分析

###### 解法一: 中序遍历

二叉搜索树的中序遍历结果是一个升序序列. 利用此性质, 我们可以使用中序遍历二叉搜索树, 到当搜索到第`k`个元素时停止遍历.

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        stack = []
        point = root
        while stack or point:
            while point:
                stack.append(point)
                point = point.left
            if stack:
                node = stack.pop()
                k -= 1
                if k == 0:
                    return node.val
                point = node.right
```





#### [270. 最接近的二叉搜索树值](https://leetcode.cn/problems/closest-binary-search-tree-value/)

难度简单132

给定一个不为空的二叉搜索树和一个目标值 target，请在该二叉搜索树中找到最接近目标值 target 的数值。

**注意：**

- 给定的目标值 target 是一个浮点数
- 题目保证在该二叉搜索树中只会存在一个最接近目标值的数

**示例：**

```
输入: root = [4,2,5,1,3]，目标值 target = 3.714286

    4
   / \
  2   5
 / \
1   3

输出: 4
```

## 其他题目

#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)

> 难度中等1636收藏分享切换为英文接收动态反馈
>
> 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。
>
> 除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。
>
> 给定二叉树的 `root` 。返回 ***在不触动警报的情况下** ，小偷能够盗取的最高金额* 。
>
> 示例 1:
>
> <img src="https://raw.githubusercontent.com/LiangsLi/tuchuang/master/picgo/20230417162617.jpeg" alt="img" style="zoom:67%;" />
>
> ```
> 输入: root = [3,2,3,null,3,null,1]
> 输出: 7 
> 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
